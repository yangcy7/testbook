{"./":{"url":"./","title":"Flask框架","keywords":"","body":"1. Flask框架1.1. 课程主要内容1.2. 学习时长1. Flask框架 1.1. 课程主要内容 视图&路由 Flask 简介 虚拟环境安装 路由各种定义 状态保持 cookie session 模板 基本使用 过滤器&自定义过滤器 模板代码复用：宏/继承/包含 模板中特有变量和函数 Flask-WTF 表单 CSRF 数据库操作 ORM Flask-SQLAlchemy 增删改查操作 案例 蓝图 单元测试 1.2. 学习时长 4天 __ "},"shi-tu-ji-lu-you.html":{"url":"shi-tu-ji-lu-you.html","title":"1. 视图及路由 ","keywords":"","body":"1. 视图及路由2. 学习目标1. 视图及路由 Flask简介 虚拟环境 路由的各种定义方式 正则路由转换器 请求参数 状态保持 上下文 Flask-Script 2. 学习目标 能够根据课件步骤安装虚拟环境 能够创建 Py2 和 Py3 版本的虚拟环境 能够使用 pip 命令安装指定版本 Flask 及其他扩展 能够写出 Flask 从对象中加载配置的代码 能够写出带有参数的路由及视图函数 能够说出 url_for 函数的作用 能够说出自定义转换器的步骤 能够说出装饰器路由实现的几个关键的类 能够说出实现 HTTP 状态保持的原理 能够说出 Flask 各个上下文对象 能够说出 Flask-Script 扩展的作用 "},"shi-tu-ji-lu-you/flaskjian-jie.html":{"url":"shi-tu-ji-lu-you/flaskjian-jie.html","title":"1.1. Flask简介 ","keywords":"","body":"1. Flask简介1.1. Web应用程序的本质1.2. Web框架1.3. Flask1. Flask简介 1.1. Web应用程序的本质 Web(World Wide Web) 诞生最初的目的，是为了利用互联网交流工作文档。 1.2. Web框架 什么是Web框架？ 协助开发者快速开发 Web 应用程序的一套功能代码 开发者只需要按照框架约定要求，在指定位置写上自己的业务逻辑代码 例如：在某个区需要成立一家医院，有两种方式： 圈地，打地基，盖楼，装修，入驻 买楼，装修，入驻 为什么要用Web框架？ web网站发展至今，特别是服务器端，涉及到的知识、内容，非常广泛。这对程序员的要求会越来越高。如果采用成熟，稳健的框架，那么一些基础的工作，比如，安全性，数据流控制等都可以让框架来处理，那么程序开发人员可以把精力放在具体的业务逻辑上面。使用框架的优点： 稳定性和可扩展性强 可以降低开发难度，提高开发效率。 总结一句话： 避 免重复造轮子 在 Python 中常用的 Web 框架有 flask django tornado 1.3. Flask Flask诞生于2010年，是Armin ronacher（人名）用 Python 语言基于 Werkzeug 工具箱编写的轻量级Web开发框架。 Flask 本身相当于一个内核，其他几乎所有的功能都要用到扩展（邮件扩展Flask-Mail，用户认证Flask-Login，数据库Flask- SQLAlchemy），都需要用第三方的扩展来实现。比如可以用 Flask 扩展加入ORM、窗体验证工具，文件上传、身份验证等。Flask 没有默认使用的数据库，你可以选择 MySQL，也可以用 NoSQL。 其 WSGI 工具箱采用 Werkzeug（路由模块），模板引擎则使用 Jinja2。这两个也是 Flask 框架的核心。 Flask 常用扩展包： Flask-SQLalchemy：操作数据库； Flask-script：插入脚本； Flask-migrate：管理迁移数据库； Flask-Session：Session存储方式指定； Flask-WTF：表单； Flask-Mail：邮件； Flask-Bable：提供国际化和本地化支持，翻译； Flask-Login：认证用户状态； Flask-OpenID：认证； Flask-RESTful：开发REST API的工具； Flask-Bootstrap：集成前端Twitter Bootstrap框架； Flask-Moment：本地化日期和时间； Flask-Admin：简单而可扩展的管理接口的框架 扩展列表：http://flask.pocoo.org/extensions/ 中文文档（http://docs.jinkan.org/docs/flask/） 英文文档（http://flask.pocoo.org/docs/0.11/） "},"shi-tu-ji-lu-you/flaskhuan-jing-an-zhuang.html":{"url":"shi-tu-ji-lu-you/flaskhuan-jing-an-zhuang.html","title":"1.2. 虚拟环境 ","keywords":"","body":"1. 虚拟环境1.1. 为什么要搭建虚拟环境?1.2. 如何搭建虚拟环境?1.3. 如何使用虚拟环境?1.4. 如何在虚拟环境中安装工具包?1. 虚拟环境 1.1. 为什么要搭建虚拟环境? 在开发过程中, 当需要使用python的某些工具包/框架时需要联网安装 比如联网安装Flask框架flask-0.10.1版本 sudo pip install flask==0.10.1 提 示：使用如上命令, 会将flask-0.10.1安装到/usr/local/lib/python2.7/dist-packages路径下 问 题：如果在一台电脑上, 想开发多个不同的项目, 需要用到同一个包的不同版本, 如果使用上面的命令, 在同一个目录下安装或者更新, 新版本会覆盖以前的版本, 其它的项目就无法运行了. 解 决方案 : 虚拟环境 作 用 : 虚拟环境可以搭建独立的python运行环境, 使得单个项目的运行环境与其它项目互不影响. 所有的虚拟环境都位于/home/下的隐藏目录.virtualenvs下 1.2. 如何搭建虚拟环境? 安装虚拟环境的命令 : sudo pip install virtualenv sudo pip install virtualenvwrapper 安装完虚拟环境后，如果提示找不到mkvirtualenv命令，须配置环境变量： # 1、创建目录用来存放虚拟环境 mkdir $HOME/.virtualenvs # 2、打开~/.bashrc文件，并添加如下： export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh # 3、运行 source ~/.bashrc 创建虚拟环境的命令 : 提示：如果不指定python版本，默认安装的是python2的虚拟环境 在python2中，创建虚拟环境 mkvirtualenv 虚拟环境名称 例 ： mkvirtualenv py_flask 在python3中，创建虚拟环境 mkvirtualenv -p python3 虚拟环境名称 例 ： mkvirtualenv -p python3 py3_flask 提示 : 创建虚拟环境需要联网 创建成功后, 会自动工作在这个虚拟环境上 工作在虚拟环境上, 提示符最前面会出现 \"虚拟环境名称\" 1.3. 如何使用虚拟环境? 查看虚拟环境的命令 : workon 两次tab键 使用虚拟环境的命令 : workon 虚拟环境名称 例 ：使用python2的虚拟环境 workon py_flask 例 ：使用python3的虚拟环境 workon py3_flask 退出虚拟环境的命令 : deactivate 删除虚拟环境的命令 : rmvirtualenv 虚拟环境名称 例 ：删除虚拟环境py3_flask 先退出：deactivate 再删除：rmvirtualenv py3_flask 1.4. 如何在虚拟环境中安装工具包? 提示 : 工具包安装的位置 : python2版本下： ~/.virtualenvs/py_flask/lib/python2.7/site-packages/ python3版本下： ~/.virtualenvs/py3_flask/lib/python3.5/site-packages python3版本下安装flask-0.10.1的包 : pip install 包名称 例 : 安装flask-0.10.1的包 pip install flask==0.10.1 查看虚拟环境中安装的包 : pip freeze "},"shi-tu-ji-lu-you/helloworld.html":{"url":"shi-tu-ji-lu-you/helloworld.html","title":"1.3. HelloWorld ","keywords":"","body":"1. HelloWorld程序1.1. 创建 Python 项目1.2. 示例：1. HelloWorld程序 1.1. 创建 Python 项目 打开 Pycharm，创建 Pure Python 类型的项目，创建项目完成之后选择之前创建的 py3_flask 作为虚拟环境 第 4 步路径可以通过在指定虚拟环境下，输入 which python 获得 1.2. 示例： 新建文件helloworld.py 导入Flask类 from flask import Flask Flask函数接收一个参数__name__，它会指向程序所在的包 app = Flask(__name__) 装饰器的作用是将路由映射到视图函数 index @app.route('/') def index(): return 'Hello World' Flask应用程序实例的 run 方法 启动 WEB 服务器 if __name__ == '__main__': app.run() 在程序运行过程中，程序实例中会使用 url_map 将装饰器路由和视图的对应关系保存起来，打印结果如下图： "},"shi-tu-ji-lu-you/xiang-guan-pei-zhi-can-shu.html":{"url":"shi-tu-ji-lu-you/xiang-guan-pei-zhi-can-shu.html","title":"1.4. 相关配置参数 ","keywords":"","body":"1. 相关配置参数1.1. 初始化参数1.2. 程序加载配置1.2.1. 使用方式1.2.2. 读取配置1.3. app.run的参数1. 相关配置参数 在上一节实现了一个最简单的 Flask 应用程序，只使用了7行代码，接来对 Flask 程序的创建，运行配置做进一步的了解，具体有： Flask 程序初始化参数 Flask 程序相关配置加载方式 app.run() 参数 1.1. 初始化参数 Flask 程序实例在创建的时候，需要默认传入当前 Flask 程序所指定的包(模块)，接下来就来详细查看一下 Flask 应用程序在创建的时候一些需要我们关注的参数： import_name Flask程序所在的包(模块)，传 __name__ 就可以 其可以决定 Flask 在访问静态文件时查找的路径 static_path 静态文件访问路径(不推荐使用，使用 static_url_path 代替) static_url_path 静态文件访问路径，可以不传，默认为：/ + static_folder static_folder 静态文件存储的文件夹，可以不传，默认为 static template_folder 模板文件存储的文件夹，可以不传，默认为 templates 1.2. 程序加载配置 在 Flask 程序运行的时候，可以给 Flask 设置相关配置，比如：配置 Debug 模式，配置数据库连接地址等等，设置 Flask 配置有以下三种方式： 从配置对象中加载(常用) app.config.form_object() 从配置文件中加载 app.config.form_pyfile() 从环境变量中加载(了解) app.config.from_envvar() 以下演练以设置应用程序的 DEBUG(调试模式) 为例，设置应用为调式模式这后，可以实现以下功能： > 程序代码修改后可以自动重启服务器 在服务器出现相关错误的时候可以直接将错误信息进行抛出到控制台打印 > 1.2.1. 使用方式 配置对象 从配置对象中加载，创建配置的类，代码如下： # 配置对象，里面定义需要给 APP 添加的一系列配置 class Config(object): DEBUG = True # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置对象中加载配置 app.config.from_object(Config) 运行测试，在修改代码之后直接保存，会自动重启服务器 配置文件 创建配置文件 config.ini，在配置文件中添加配置 使用代码去加载配置 # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 从配置文件中加载配置 app.config.from_pyfile('config.ini') 环境变量(了解) 编辑运行的相关配置 使用代码去加载配置 # 创建 Flask 类的对象,指向程序所在的包的名称 app = Flask(__name__) # 加载指定环境变量名称所对应的相关配置 app.config.from_envvar('FLASKCONFIG') 1.2.2. 读取配置 app.config.get() 在视图函数中使用 current_app.config.get() 注：Flask 应用程序将一些常用的配置设置成了应用程序对象的属性，也可以通过属性直接设置/获取某些配置：app.debug = True 1.3. app.run的参数 可以指定运行的主机IP地址，端口，是否开启调试模式 app.run(host=\"0.0.0.0\", port=5000, debug = True) "},"shi-tu-ji-lu-you/lu-you-de-ge-zhong-ding-yi.html":{"url":"shi-tu-ji-lu-you/lu-you-de-ge-zhong-ding-yi.html","title":"1.5. 路由基本定义 ","keywords":"","body":"1. 路由基本定义1.1. 指定路由地址1.2. 给路由传参示例1.3. 指定请求方式1.3.1. 使用 PostMan 对请求进行测试1. 路由基本定义 明确路由定义的参数，请求方式指定 PostMan 的使用 1.1. 指定路由地址 # 指定访问路径为 demo1 @app.route('/demo1') def demo1(): return 'demo1' 1.2. 给路由传参示例 有时我们需要将同一类 URL 映射到同一个视图函数处理，比如：使用同一个视图函数来显示不同用户的个人信息。 # 路由传递参数 @app.route('/user/&lt;user_id&gt;') def user_info(user_id): return 'hello %s' % user_id 路由传递的参数默认当做 string 处理，也可以指定参数的类型 # 路由传递参数 @app.route('/user/&lt;int:user_id&gt;') def user_info(user_id): return 'hello %d' % user_id 这里指定int，尖括号中的内容是动态的，在此暂时可以理解为接受 int 类型的值，实际上 int 代表使用 IntegerConverter 去处理 url 传入的参数 1.3. 指定请求方式 在 Flask 中，定义一个路由，默认的请求方式为： GET OPTIONS(自带) HEAD(自带) 如果想添加请求方试，那么可以如下指定： @app.route('/demo2', methods=['GET', 'POST']) def demo2(): # 直接从请求中取到请求方式并返回 return request.method demo2 请求方式为： 1.3.1. 使用 PostMan 对请求进行测试 PostMan 是一款功能强大的网页调试与发送网页 HTTP 请求的 Chrome 插件，可以直接去对我们写出来的路由和视图函数进行调试，作为后端程序员是必须要知道的一个工具。 安装方式1：去 Chrome 商店直接搜索 PostMan 扩展程序进行安装 安装方式2：https://www.getpostman.com/ 官网下载桌面版 安装方式3：将已下载好的 PostMan 插件文件夹拖入到浏览器 打开 Chrome 的扩展程序页面，打开 开发者模式 选项 将插件文件夹拖入到浏览器(或者点击加载已解压的扩展程序选择文件夹) 在 Mac 下生成桌面图标，可以点击启动 在 ubuntu 旧版的 Chrome 浏览器中会显示以下效果，可以直接点击启动 使用 PostMan，打开之后，会弹出注册页面，选择下方的 Skip this,go straight to the app 进行程序 "},"shi-tu-ji-lu-you/shi-tu-chang-yong-luo-ji.html":{"url":"shi-tu-ji-lu-you/shi-tu-chang-yong-luo-ji.html","title":"1.6. 视图常用逻辑 ","keywords":"","body":"1. 视图常用逻辑1.1. 返回JSON1.2. 重定向1.3. 自定义状态码1. 视图常用逻辑 返回 JSON 重定向 url_for 自定义状态码 1.1. 返回JSON 在使用 Flask 写一个接口时候需要给客户端返回 JSON 数据，在 Flask 中可以直接使用 jsonify 生成一个 JSON 的响应 # 返回JSON @app.route('/demo4') def demo4(): json_dict = { \"user_id\": 10, \"user_name\": \"laowang\" } return jsonify(json_dict) 不推荐使用 json.dumps 转成 JSON 字符串直接返回，因为返回的数据要符合 HTTP 协议规范，如果是 JSON 需要指定 content- type:application/json 1.2. 重定向 重定向到 黑 马 官网 # 重定向 @app.route('/demo5') def demo5(): return redirect('http://www.itheima.com') 重定向到自己写的视图函数 可以直接填写自己 url 路径 也可以使用 url_for 生成指定视图函数所对应的 url @app.route('/demo1') def demo1(): return 'demo1' # 重定向 @app.route('/demo5') def demo5(): return redirect(url_for('demo1')) 重定向到带有参数的视图函数 在 url_for 函数中传入参数 # 路由传递参数 @app.route('/user/&lt;int:user_id&gt;') def user_info(user_id): return 'hello %d' % user_id # 重定向 @app.route('/demo5') def demo5(): # 使用 url_for 生成指定视图函数所对应的 url return redirect(url_for('user_info', user_id=100)) 1.3. 自定义状态码 在 Flask 中，可以很方便的返回自定义状态码，以实现不符合 http 协议的状态码，例如：status code: 666 @app.route('/demo6') def demo6(): return '状态码为 666', 666 "},"shi-tu-ji-lu-you/zheng-ze-pi-pei-lu-you.html":{"url":"shi-tu-ji-lu-you/zheng-ze-pi-pei-lu-you.html","title":"1.7. 正则匹配路由 ","keywords":"","body":"1. 正则匹配路由1.1. 代码实现1.2. 自定义转换器其他两个函数实现2. 系统自带转换器1. 正则匹配路由 在 web 开发中，可能会出现限制用户访问规则的场景，那么这个时候就需要用到正则匹配，根据自己的规则去限定请求参数再进行访问 具体实现步骤为： 导入转换器基类：在 Flask 中，所有的路由的匹配规则都是使用转换器对象进行记录 自定义转换器：自定义类继承于转换器基类 添加转换器到默认的转换器字典中 使用自定义转换器实现自定义匹配规则 1.1. 代码实现 导入转换器基类 from werkzeug.routing import BaseConverter 自定义转换器 # 自定义正则转换器 class RegexConverter(BaseConverter): def __init__(self, url_map, *args): super(RegexConverter, self).__init__(url_map) # 将接受的第1个参数当作匹配规则进行保存 self.regex = args[0] 添加转换器到默认的转换器字典中，并指定转换器使用时名字为: re app = Flask(__name__) # 将自定义转换器添加到转换器字典中，并指定转换器使用时名字为: re app.url_map.converters['re'] = RegexConverter 使用转换器去实现自定义匹配规则 当前此处定义的规则是：3位数字 @app.route('/user/') def user_info(user_id): return \"user_id 为 %s\" % user_id 运行测试：http://127.0.0.1:5000/user/123 ，如果访问的url不符合规则，会提示找不到页面 1.2. 自定义转换器其他两个函数实现 继承于自定义转换器之后，还可以实现 to_python 和 to_url 这两个函数去对匹配参数做进一步处理： to_python： 该函数参数中的 value 值代表匹配到的值，可输出进行查看 匹配完成之后，对匹配到的参数作最后一步处理再返回，比如：转成 int 类型的值再返回： class RegexConverter(BaseConverter): def __init__(self, url_map, *args): super(RegexConverter, self).__init__(url_map) # 将接受的第1个参数当作匹配规则进行保存 self.regex = args[0] def to_python(self, value): return int(value) 运行测试，在视图函数中可以查看参数的类型，由之前默认的 str 已变成 int 类型的值 to_url: 在使用 url_for 去获取视图函数所对应的 url 的时候，会调用此方法对 url_for 后面传入的视图函数参数做进一步处理 具体可参见 Flask 的 app.py 中写的示例代码：ListConverter 2. 系统自带转换器 DEFAULT_CONVERTERS = { 'default': UnicodeConverter, 'string': UnicodeConverter, 'any': AnyConverter, 'path': PathConverter, 'int': IntegerConverter, 'float': FloatConverter, 'uuid': UUIDConverter, } 系统自带的转换器具体使用方式在每种转换器的注释代码中有写，请留意每种转换器初始化的参数。 "},"shi-tu-ji-lu-you/yi-chang-bu-huo.html":{"url":"shi-tu-ji-lu-you/yi-chang-bu-huo.html","title":"1.8. 异常捕获 ","keywords":"","body":"1. 异常捕获1.1. HTTP 异常主动抛出1.2. 捕获错误1. 异常捕获 1.1. HTTP 异常主动抛出 abort 方法 抛出一个给定状态代码的 HTTPException 或者 指定响应，例如想要用一个页面未找到异常来终止请求，你可以调用 abort(404)。 参数： code - HTTP的错误状态码 # abort(404) abort(500) 抛出状态码的话，只能抛出 HTTP 协议的错误状态码 1.2. 捕获错误 errorhandler 装饰器 注册一个错误处理程序，当程序抛出指定错误状态码的时候，就会调用该装饰器所装饰的方法 参数： code_or_exception - HTTP的错误状态码或指定异常 例如统一处理状态码为500的错误给用户友好的提示： @app.errorhandler(500) def internal_server_error(e): return '服务器搬家了' 捕获指定异常 @app.errorhandler(ZeroDivisionError) def zero_division_error(e): return '除数不能为0' "},"shi-tu-ji-lu-you/qing-qiu-gou-zi.html":{"url":"shi-tu-ji-lu-you/qing-qiu-gou-zi.html","title":"1.9. 请求勾子 ","keywords":"","body":"1. 请求勾子1.1. 代码测试1. 请求勾子 在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如： 在请求开始时，建立数据库连接； 在请求开始时，根据需求进行权限校验； 在请求结束时，指定数据的交互格式； 为了让每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。 请求钩子是通过装饰器的形式实现，Flask支持如下四种请求钩子： before_first_request 在处理第一个请求前执行 before_request 在每次请求前执行 如果在某修饰的函数中返回了一个响应，视图函数将不再被调用 after_request 如果没有抛出错误，在每次请求后执行 接受一个参数：视图函数作出的响应 在此函数中可以对响应值在返回之前做最后一步修改处理 需要将参数中的响应在此参数中进行返回 teardown_request： 在每次请求后执行 接受一个参数：错误信息，如果有相关错误抛出 1.1. 代码测试 from flask import Flask from flask import abort app = Flask(__name__) # 在第一次请求之前调用，可以在此方法内部做一些初始化操作 @app.before_first_request def before_first_request(): print(\"before_first_request\") # 在每一次请求之前调用，这时候已经有请求了，可能在这个方法里面做请求的校验 # 如果请求的校验不成功，可以直接在此方法中进行响应，直接return之后那么就不会执行视图函数 @app.before_request def before_request(): print(\"before_request\") # if 请求不符合条件: # return \"laowang\" # 在执行完视图函数之后会调用，并且会把视图函数所生成的响应传入,可以在此方法中对响应做最后一步统一的处理 @app.after_request def after_request(response): print(\"after_request\") response.headers[\"Content-Type\"] = \"application/json\" return response # 请每一次请求之后都会调用，会接受一个参数，参数是服务器出现的错误信息 @app.teardown_request def teardown_request(e): print(\"teardown_request\") @app.route('/') def index(): return 'index' if __name__ == '__main__': app.run(debug=True) 在第1次请求时的打印： before_first_request before_request after_request teardown_request 在第2次请求时的打印： before_request after_request teardown_request "},"shi-tu-ji-lu-you/flaskzhuang-shi-qi-lu-you-ju-ti-shi-xian.html":{"url":"shi-tu-ji-lu-you/flaskzhuang-shi-qi-lu-you-ju-ti-shi-xian.html","title":"1.10. 装饰器路由具体实现 ","keywords":"","body":"1. 装饰器路由具体实现梳理1. 装饰器路由具体实现梳理 Flask有两大核心：Werkzeug和Jinja2 - Werkzeug实现路由、调试和Web服务器网关接口 - Jinja2实现了模板。 Werkzeug是一个遵循WSGI协议的python函数库 - 其内部实现了很多Web框架底层的东西，比如request和response对象； - 与WSGI规范的兼容；支持Unicode； - 支持基本的会话管理和签名Cookie； - 集成URL请求路由等。 Werkzeug库的 routing 模块负责实现 URL 解析。不同的 URL 对应不同的视图函数，routing模块会对请求信息的URL进行解析，匹配到URL对应的视图函数，执行该函数以此生成一个响应信息。 routing模块内部有： Rule类 用来构造不同的URL模式的对象，路由URL规则 Map类 存储所有的URL规则和一些配置参数 BaseConverter的子类 负责定义匹配规则 MapAdapter类 负责协调Rule做具体的匹配的工作 "},"shi-tu-ji-lu-you/huo-qu-qing-qiu-can-shu.html":{"url":"shi-tu-ji-lu-you/huo-qu-qing-qiu-can-shu.html","title":"1.11. 获取请求参数 ","keywords":"","body":"1. request1.1. 示例1. request request 就是flask中代表当前请求的 request 对象，其中一个请求上下文变量(理解成全局变量，在视图函数中直接使用可以取到当前本次请求) 常用的属性如下： 属性 说明 类型 data 记录请求的数据，并转换为字符串 \\* form 记录请求中的表单数据 MultiDict args 记录请求中的查询参数 MultiDict cookies 记录请求中的cookie信息 Dict headers 记录请求中的报文头 EnvironHeaders method 记录请求使用的HTTP方法 GET/POST url 记录请求的URL地址 string files 记录请求上传的文件 \\* 1.1. 示例 获取上传的图片并保存到本地 @app.route('/', methods=['POST']) def index(): pic = request.files.get('pic') pic.save('./static/aaa.png') return 'index' "},"shi-tu-ji-lu-you/zhuang-tai-bao-chi.html":{"url":"shi-tu-ji-lu-you/zhuang-tai-bao-chi.html","title":"1.12. 状态保持 ","keywords":"","body":"1. 状态保持1. 状态保持 因为 http 是一种无状态协议，浏览器请求服务器是无状态的。 无 状态：指一次用户请求时，浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。 无 状态原因：浏览器与服务器是使用 socket 套接字进行通信的，服务器将请求结果返回给浏览器之后，会关闭当前的 socket 连接，而且服务器也会在处理页面完毕之后销毁页面对象。 有时需要保持下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等 实现状态保持主要有两种方式： 在客户端存储信息使用Cookie 在服务器端存储信息使用Session 无状态协议： > 协议对于事务处理没有记忆能力 对同一个 url 请求没有上下文关系 3. 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 人生若只如初见 > 状态举例： 有状态： A：你今天中午吃的啥？ B：吃的大盘鸡。 A：味道怎么样呀？ B：还不错，挺好吃的。 无状态： A：你今天中午吃的啥？ B：吃的大盘鸡。 A：味道怎么样呀？ B：？？？啊？啥？啥味道怎么样？ 所以需要cookie这种东西： A：你今天中午吃的啥？ B：吃的大盘鸡。 A：你今天中午吃的大盘鸡味道怎么样呀？ B：还不错，挺好吃的。 "},"shi-tu-ji-lu-you/zhuang-tai-bao-chi/cookie.html":{"url":"shi-tu-ji-lu-you/zhuang-tai-bao-chi/cookie.html","title":"1.12.1. Cookie ","keywords":"","body":"1. Cookie1.1. 设置cookie1.2. 获取cookie1. Cookie Cookie ：指某些网站为了辨别用户身份、进行会话跟踪而储存在用户本地的数据（通常经过加密）。 复数形式Cookies。 Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。 Cookie是由服务器端生成，发送给客户端浏览器，浏览器会将Cookie的key/value保存，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。 Cookie的key/value可以由服务器端自己定义。 应 用： 最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookie的功用。 网站的广告推送，经常遇到访问某个网站时，会弹出小窗口，展示我们曾经在购物网站上看过的商品信息。 购物车，用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookie，以便在最后付款时提取信息。 提 示： Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用 Cookie基于域名安全，不同域名的Cookie是不能互相访问的 如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息 浏览器的同源策略 当浏览器请求某网站时，会将本网站下所有Cookie信息提交给服务器，所以在request中可以读取Cookie信息 1.1. 设置cookie from flask imoprt Flask,make_response @app.route('/cookie') def set_cookie(): resp = make_response('this is to set cookie') resp.set_cookie('username', 'itcast') return resp 设置过期时间 @app.route('/cookie') def set_cookie(): response = make_response('hello world') response.set_cookie('username', 'itheima', max_age=3600) return response 1.2. 获取cookie from flask import Flask,request #获取cookie @app.route('/request') def resp_cookie(): resp = request.cookies.get('username') return resp "},"shi-tu-ji-lu-you/zhuang-tai-bao-chi/session.html":{"url":"shi-tu-ji-lu-you/zhuang-tai-bao-chi/session.html","title":"1.12.2. Session ","keywords":"","body":"1. Session1.1. session数据的获取1. Session 对于敏感、重要的信息，建议要存储在服务器端，不能存储在浏览器中，如用户名、余额、等级、验证码等信息 在服务器端进行状态保持的方案就是Session Session 依赖于Cookie 1.1. session数据的获取 session:请求上下文对象，用于处理http请求中的一些数据内容 @app.route('/index1') def index1(): session['username'] = 'itcast' return redirect(url_for('index')) @app.route('/') def index(): return session.get('username') 记得设置secret_key: app.secret_key = 'itheima' secret_key的作用：https://segmentfault.com/q/1010000007295395 "},"shi-tu-ji-lu-you/shang-xia-wen.html":{"url":"shi-tu-ji-lu-you/shang-xia-wen.html","title":"1.13. 上下文 ","keywords":"","body":"1. 上下文1.1. 请求上下文(request context)1.2. 应用上下文(application context)1.2.1. current_app1.2.2. g变量1.3. 两者区别：1. 上下文 上下文：相当于一个容器，保存了 Flask 程序运行过程中的一些信息。 Flask中有两种上下文，请求上下文和应用上下文 1.1. 请求上下文(request context) 思考：在视图函数中，如何取到当前请求的相关数据？比如：请求地址，请求方式，cookie等等 在 flask 中，可以直接在视图函数中使用 request 这个对象进行获取相关数据，而 request 就是请求上下文的对象，保存了当前本次请求的相关数据，请求上下文对象有：request、session request 封装了HTTP请求的内容，针对的是http请求。举例：user = request.args.get('user')，获取的是get请求的参数。 session 用来记录请求会话中的信息，针对的是用户信息。举例：session['name'] = user.id，可以记录用户信息。还可以通过session.get('name')获取用户信息。 1.2. 应用上下文(application context) 它的字面意思是 应用上下文，但它不是一直存在的，它只是request context 中的一个对 app 的代理(人)，所谓local proxy。它的作用主要是帮助 request 获取当前的应用，它是伴 request 而生，随 request 而灭的。 应用上下文对象有：current_app，g 1.2.1. current_app 应用程序上下文,用于存储应用程序中的变量，可以通过current_app.name打印当前app的名称，也可以在current_app中存储一些变量，例如： 应用的启动脚本是哪个文件，启动时指定了哪些参数 加载了哪些配置文件，导入了哪些配置 连了哪个数据库 有哪些public的工具类、常量 应用跑再哪个机器上，IP多少，内存多大 current_app.name current_app.test_value='value' 1.2.2. g变量 g 作为 flask 程序全局的一个临时变量,充当者中间媒介的作用,我们可以通过它传递一些数据，g 保存的是当前请求的全局变量，不同的请求会有不同的全局变量，通过不同的thread id区别 g.name='abc' 注意：不同的请求，会有不同的全局变量 1.3. 两者区别： 请求上下文：保存了客户端和服务器交互的数据 应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用信息等 上下文中的对象只能在指定上下文中使用，超出范围不能使用 请求上下文和应用上下文原理实现：https://segmentfault.com/a/1190000004223296 "},"shi-tu-ji-lu-you/flask-script.html":{"url":"shi-tu-ji-lu-you/flask-script.html","title":"1.14. Flask-Script ","keywords":"","body":"1. Flask-Script 扩展1.1. 代码实现1. Flask-Script 扩展 通过使用Flask- Script扩展，我们可以在Flask服务器启动的时候，通过命令行的方式传入参数。而不仅仅通过app.run()方法中传参，比如我们可以通过： python hello.py runserver -host ip地址 以上代码告诉服务器在哪个网络接口监听来自客户端的连接。默认情况下，服务器只监听来自服务器所在的计算机发起的连接，即localhost连接。 我们可以通过python hello.py runserver --help来查看参数。 1.1. 代码实现 安装 Flask-Script 扩展 pip install flask-script 集成 Flask-Script from flask import Flask from flask_script import Manager app = Flask(__name__) # 把 Manager 类和应用程序实例进行关联 manager = Manager(app) @app.route('/') def index(): return '床前明月光' if __name__ == \"__main__\": manager.run() Flask-Script 还可以为当前应用程序添加脚本命令，后续项目中会使用到 "},"mo-ban.html":{"url":"mo-ban.html","title":"2. 模板 ","keywords":"","body":"1. 模板2. 学习目标1. 模板 基本使用 过滤器&自定义过滤器 控制代码块 宏、继承、包含 Flask 的模板中特有变量和方法 web表单 CSRF 2. 学习目标 能够写出 jinja2 中变量代码块和控制代码块的格式 能够写出在模板中字典，列表的取值方式 能够写出数组反转的自定义过滤器（使用1种方式即可） 能够说出Flask中模板代码复用的三种方式 能够使用代码实现模板继承的功能 能够说出可以在模板中直接使用的 Flask 变量和函数 能够使用 Flask-WTF 扩展实现注册表单 能够说出 CSRF 攻击的原理 "},"mo-ban/jinja2mo-ban-yin-qing.html":{"url":"mo-ban/jinja2mo-ban-yin-qing.html","title":"2.1. Jinja2简介 ","keywords":"","body":"1. Jinja2模板引擎简介1.1. 模板1.2. Jinja21.2.1. 两个概念：1.2.2. 渲染模版函数1.2.3. 使用1.2.4. 注释1. Jinja2模板引擎简介 1.1. 模板 在前面的示例中，视图函数的主要作用是生成请求的响应，这是最简单的请求。实际上，视图函数有两个作用：处理业务逻辑和返回响应内容。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。本节学到的模板，它的作用即是承担视图函数的另一个作用，即返回响应内容。 模板其实是一个包含响应文本的文件，其中用占位符(变量)表示动态部分，告诉模板引擎其具体的值需要从使用的数据中获取 使用真实值替换变量，再返回最终得到的字符串，这个过程称为\"渲染\" Flask是使用 Jinja2 这个模板引擎来渲染模板 使用模板的好处： 视图函数只负责业务逻辑和数据处理(业务逻辑方面) 而模板则取到视图函数的数据结果进行展示(视图展示方面) 代码结构清晰，耦合度低 1.2. Jinja2 1.2.1. 两个概念： Jinja2：是 Python 下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于 Django 的模板引擎，并扩展了其语法和一系列强大的功能，其是Flask内置的模板语言。 模板语言：是一种被设计来自动生成文档的简单文本格式，在模板语言中，一般都会把一些变量传给模板，替换模板的特定位置上预先定义好的占位变量名。 1.2.2. 渲染模版函数 Flask提供的 render_template 函数封装了该模板引擎 render_template 函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值。 1.2.3. 使用 {{}} 来表示变量名，这种 {{}} 语法叫做 变 量代码块 &lt;h1&gt;{{ post.title }}&lt;/h1&gt; Jinja2 模版中的变量代码块可以是任意 Python 类型或者对象，只要它能够被 Python 的 str() 方法转换为一个字符串就可以，比如，可以通过下面的方式显示一个字典或者列表中的某个元素: {{your_dict['key']}} {{your_list[0]}} 用 { %% } 定义的 控 制代码块，可以实现一些语言层次的功能，比如循环或者if语句 {% if user %} {{ user }} {% else %} hello! &lt;ul&gt; {% for index in indexs %} &lt;li&gt; {{ index }} &lt;/li&gt; {% endfor %} &lt;/ul&gt; 1.2.4. 注释 使用 {# #} 进行注释，注释的内容不会在html中被渲染出来 {# {{ name }} #} "},"mo-ban/jinja2mo-ban-yin-qing-shi-yong.html":{"url":"mo-ban/jinja2mo-ban-yin-qing-shi-yong.html","title":"2.2. 模板的使用 ","keywords":"","body":"1. 模板的使用1. 模板的使用 在项目下创建 templates 文件夹，用于存放所有的模板文件，并在目录下创建一个模板html文件 temp_demo1.html &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我的模板html内容 &lt;/body&gt; &lt;/html&gt; 设置 templates 文件夹属性以便能够在代码中有智能提示 设置 html 中的模板语言，以便在 html 有智能提示 创建视图函数，将该模板内容进行渲染返回 @app.route('/') def index(): return render_template('temp_demo1.html') 访问：http://127.0.0.1:5000/ 运行测试 代码中传入字符串，列表，字典到模板中 @app.route('/') def index(): # 往模板中传入的数据 my_str = 'Hello 黑马程序员' my_int = 10 my_array = [3, 4, 2, 1, 7, 9] my_dict = { 'name': 'xiaoming', 'age': 18 } return render_template('temp_demo1.html', my_str=my_str, my_int=my_int, my_array=my_array, my_dict=my_dict ) 模板中代码 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 我的模板html内容 &lt;br/&gt;{{ my_str }} &lt;br/&gt;{{ my_int }} &lt;br/&gt;{{ my_array }} &lt;br/&gt;{{ my_dict }} &lt;/body&gt; &lt;/html&gt; 运行效果 我的模板html内容Hello 黑马程序员10[3, 4, 2, 1, 7, 9]{'name': 'xiaoming', 'age': 18} 相关运算，取值 &lt;br/&gt; my_int + 10 的和为：{{ my_int + 10 }} &lt;br/&gt; my_int + my_array第0个值的和为：{{ my_int + my_array[0] }} &lt;br/&gt; my_array 第0个值为：{{ my_array[0] }} &lt;br/&gt; my_array 第1个值为：{{ my_array.1 }} &lt;br/&gt; my_dict 中 name 的值为：{{ my_dict['name'] }} &lt;br/&gt; my_dict 中 age 的值为：{{ my_dict.age }} 结果 my_int + 10 的和为：20 my_int + my_array第0个值的和为：13 my_array 第0个值为：3 my_array 第1个值为：4 my_dict 中 name 的值为：xiaoming my_dict 中 age 的值为：18 "},"mo-ban/guo-lv-qi.html":{"url":"mo-ban/guo-lv-qi.html","title":"2.3. 过滤器 ","keywords":"","body":"1. 过滤器1.1. 链式调用1.2. 常见内建过滤器1.2.1. 字符串操作1.2.2. 列表操作1.2.3. 语句块过滤1. 过滤器 过滤器的本质就是函数。有时候我们不仅仅只是需要输出变量的值，我们还需要修改变量的显示，甚至格式化、运算等等，而在模板中是不能直接调用 Python 中的某些方法，那么这就用到了过滤器。 使用方式： 过滤器的使用方式为：变量名 | 过滤器。 {{variable | filter_name(*args)}} 如果没有任何参数传给过滤器,则可以把括号省略掉 {{variable | filter_name}} 如：``，这个过滤器的作用：把变量variable 的值的首字母转换为大写，其他字母转换为小写 1.1. 链式调用 在 jinja2 中，过滤器是可以支持链式调用的，示例如下： {{ \"hello world\" | reverse | upper }} 1.2. 常见内建过滤器 1.2.1. 字符串操作 safe：禁用转义 &lt;p&gt;{{ '&lt;em&gt;hello&lt;/em&gt;' | safe }}&lt;/p&gt; capitalize：把变量值的首字母转成大写，其余字母转小写 &lt;p&gt;{{ 'hello' | capitalize }}&lt;/p&gt; lower：把值转成小写 &lt;p&gt;{{ 'HELLO' | lower }}&lt;/p&gt; upper：把值转成大写 &lt;p&gt;{{ 'hello' | upper }}&lt;/p&gt; title：把值中的每个单词的首字母都转成大写 &lt;p&gt;{{ 'hello' | title }}&lt;/p&gt; reverse：字符串反转 &lt;p&gt;{{ 'olleh' | reverse }}&lt;/p&gt; format：格式化输出 &lt;p&gt;{{ '%s is %d' | format('name',17) }}&lt;/p&gt; striptags：渲染之前把值中所有的HTML标签都删掉 &lt;p&gt;{{ '&lt;em&gt;hello&lt;/em&gt;' | striptags }}&lt;/p&gt; truncate: 字符串截断 &lt;p&gt;{{ 'hello every one' | truncate(9)}}&lt;/p&gt; 1.2.2. 列表操作 first：取第一个元素 &lt;p&gt;{{ [1,2,3,4,5,6] | first }}&lt;/p&gt; last：取最后一个元素 &lt;p&gt;{{ [1,2,3,4,5,6] | last }}&lt;/p&gt; length：获取列表长度 &lt;p&gt;{{ [1,2,3,4,5,6] | length }}&lt;/p&gt; sum：列表求和 &lt;p&gt;{{ [1,2,3,4,5,6] | sum }}&lt;/p&gt; sort：列表排序 &lt;p&gt;{{ [6,2,3,1,5,4] | sort }}&lt;/p&gt; 1.2.3. 语句块过滤 {% filter upper %} #一大堆文字# {% endfilter %} "},"mo-ban/zi-ding-yi-guo-lv-qi.html":{"url":"mo-ban/zi-ding-yi-guo-lv-qi.html","title":"2.4. 自定义过滤器 ","keywords":"","body":"1. 自定义过滤器1. 自定义过滤器 过滤器的本质是函数。当模板内置的过滤器不能满足需求，可以自定义过滤器。自定义过滤器有两种实现方式： 一种是通过Flask应用对象的 add_template_filter 方法 通过装饰器来实现自定义过滤器 重 要：自定义的过滤器名称如果和内置的过滤器重名，会覆盖内置的过滤器。 需求：添加列表反转的过滤器 方式一 通过调用应用程序实例的 add_template_filter 方法实现自定义过滤器。该方法第一个参数是函数名，第二个参数是自定义的过滤器名称： def do_listreverse(li): # 通过原列表创建一个新列表 temp_li = list(li) # 将新列表进行返转 temp_li.reverse() return temp_li app.add_template_filter(do_listreverse,'lireverse') 方式二 用装饰器来实现自定义过滤器。装饰器传入的参数是自定义的过滤器名称。 @app.template_filter('lireverse') def do_listreverse(li): # 通过原列表创建一个新列表 temp_li = list(li) # 将新列表进行返转 temp_li.reverse() return temp_li 在 html 中使用该自定义过滤器 &lt;br/&gt; my_array 原内容：{{ my_array }} &lt;br/&gt; my_array 反转：{{ my_array | lireverse }} 运行结果 my_array 原内容：[3, 4, 2, 1, 7, 9] my_array 反转：[9, 7, 1, 2, 4, 3] "},"mo-ban/kong-zhi-dai-ma-kuai.html":{"url":"mo-ban/kong-zhi-dai-ma-kuai.html","title":"2.5. 控制代码块 ","keywords":"","body":"1. 控制代码块1.1. if语句1.2. 循环1.3. 示例程序1. 控制代码块 控制代码块主要包含两个： - if/else if /else / endif - for / endfor 1.1. if语句 Jinja2 语法中的if语句跟 Python 中的 if 语句相似,后面的布尔值或返回布尔值的表达式将决定代码中的哪个流程会被执行: {%if user.is_logged_in() %} &lt;a href='/logout'&gt;Logout&lt;/a&gt; {% else %} &lt;a href='/login'&gt;Login&lt;/a&gt; {% endif %} 过滤器可以被用在 if 语句中: {% if comments | length > 0 %} There are {{ comments | length }} comments {% else %} There are no comments {% endif %} 1.2. 循环 我们可以在 Jinja2 中使用循环来迭代任何列表或者生成器函数 {% for post in posts %} &lt;div&gt; &lt;h1&gt;{{ post.title }}&lt;/h1&gt; &lt;p&gt;{{ post.text | safe }}&lt;/p&gt; &lt;/div&gt; {% endfor %} 循环和if语句可以组合使用，以模拟 Python 循环中的 continue 功能，下面这个循环将只会渲染post.text不为None的那些post： {% for post in posts if post.text %} &lt;div&gt; &lt;h1&gt;{{ post.title }}&lt;/h1&gt; &lt;p&gt;{{ post.text | safe }}&lt;/p&gt; &lt;/div&gt; {% endfor %} 在一个 for 循环块中你可以访问这些特殊的变量: 变量 描述 loop.index 当前循环迭代的次数（从 1 开始） loop.index0 当前循环迭代的次数（从 0 开始） loop.revindex 到循环结束需要迭代的次数（从 1 开始） loop.revindex0 到循环结束需要迭代的次数（从 0 开始） loop.first 如果是第一次迭代，为 True 。 loop.last 如果是最后一次迭代，为 True 。 loop.length 序列中的项目数。 loop.cycle 在一串序列间期取值的辅助函数。见下面示例程序。 在循环内部,你可以使用一个叫做loop的特殊变量来获得关于for循环的一些信息 比如：要是我们想知道当前被迭代的元素序号，并模拟Python中的enumerate函数做的事情，则可以使用loop变量的index属性,例如: {% for post in posts%} {{loop.index}}, {{post.title}} {% endfor %} 会输出这样的结果 1, Post title 2, Second Post cycle函数会在每次循环的时候,返回其参数中的下一个元素,可以拿上面的例子来说明: {% for post in posts%} {{loop.cycle('odd','even')}} {{post.title}} {% endfor %} 会输出这样的结果： odd Post Title even Second Post 1.3. 示例程序 实现的效果 准备数据 # 只显示4行数据，背景颜色依次为：黄，绿，红，紫 my_list = [ { \"id\": 1, \"value\": \"我爱工作\" }, { \"id\": 2, \"value\": \"工作使人快乐\" }, { \"id\": 3, \"value\": \"沉迷于工作无法自拔\" }, { \"id\": 4, \"value\": \"日渐消瘦\" }, { \"id\": 5, \"value\": \"以梦为马，越骑越傻\" } ] 模板代码 {% for item in my_list if item.id != 5 %} {% if loop.index == 1 %} &lt;li style=\"background-color: orange\"&gt;{{ item.value }}&lt;/li&gt; {% elif loop.index == 2 %} &lt;li style=\"background-color: green\"&gt;{{ item.value }}&lt;/li&gt; {% elif loop.index == 3 %} &lt;li style=\"background-color: red\"&gt;{{ item.value }}&lt;/li&gt; {% else %} &lt;li style=\"background-color: purple\"&gt;{{ item.value }}&lt;/li&gt; {% endif %} {% endfor %} "},"mo-ban/mo-ban-dai-ma-fu-yong.html":{"url":"mo-ban/mo-ban-dai-ma-fu-yong.html","title":"2.6. 模板代码复用 ","keywords":"","body":"1. 模板代码复用1. 模板代码复用 在模板中，可能会遇到以下情况： 多个模板具有完全相同的顶部和底部内容 多个模板中具有相同的模板代码内容，但是内容中部分值不一样 多个模板中具有完全相同的 html 代码块内容 像遇到这种情况，可以使用 JinJa2 模板中的 宏、继承、包含来进行实现 "},"mo-ban/mo-ban-dai-ma-fu-yong/hong.html":{"url":"mo-ban/mo-ban-dai-ma-fu-yong/hong.html","title":"2.6.1. 宏 ","keywords":"","body":"1. 宏1.1. 使用1.2. 代码演练1. 宏 对宏(macro)的理解： 把它看作 Jinja2 中的一个函数，它会返回一个模板或者 HTML 字符串 为了避免反复地编写同样的模板代码，出现代码冗余，可以把他们写成函数以进行重用 需要在多处重复使用的模板代码片段可以写入单独的文件，再包含在所有模板中，以避免重复 1.1. 使用 定义宏 {% macro input(name,value='',type='text') %} &lt;input type=\"{{type}}\" name=\"{{name}}\" value=\"{{value}}\" class=\"form-control\"&gt; {% endmacro %} 调用宏 {{ input('name' value='zs')}} 这会输出 &lt;input type=\"text\" name=\"name\" value=\"zs\" class=\"form-control\"&gt; 把宏单独抽取出来，封装成html文件，其它模板中导入使用，文件名可以自定义macro.html {% macro function(type='text', name='', value='') %} &lt;input type=\"{{type}}\" name=\"{{name}}\" value=\"{{value}}\" class=\"form-control\"&gt; {% endmacro %} 在其它模板文件中先导入，再调用 {% import 'macro.html' as func %} {% func.function() %} 1.2. 代码演练 使用宏之前代码 &lt;form&gt; &lt;label&gt;用户名：&lt;/label&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; &lt;label&gt;身份证号：&lt;/label&gt;&lt;input type=\"text\" name=\"idcard\"&gt;&lt;br/&gt; &lt;label&gt;密码：&lt;/label&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;br/&gt; &lt;label&gt;确认密码：&lt;/label&gt;&lt;input type=\"password\" name=\"password2\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; 定义宏 {#定义宏，相当于定义一个函数，在使用的时候直接调用该宏，传入不同的参数就可以了#} {% macro input(label=\"\", type=\"text\", name=\"\", value=\"\") %} &lt;label&gt;{{ label }}&lt;/label&gt;&lt;input type=\"{{ type }}\" name=\"{{ name }}\" value=\"{{ value }}\"&gt; {% endmacro %} 使用宏 &lt;form&gt; {{ input(\"用户名：\", name=\"username\") }}&lt;br/&gt; {{ input(\"身份证号：\", name=\"idcard\") }}&lt;br/&gt; {{ input(\"密码：\", type=\"password\", name=\"password\") }}&lt;br/&gt; {{ input(\"确认密码：\", type=\"password\", name=\"password2\") }}&lt;br/&gt; {{ input(type=\"submit\", value=\"注册\") }} &lt;/form&gt; "},"mo-ban/mo-ban-dai-ma-fu-yong/ji-cheng.html":{"url":"mo-ban/mo-ban-dai-ma-fu-yong/ji-cheng.html","title":"2.6.2. 继承 ","keywords":"","body":"1. 模板继承1.1. 父模板1.2. 子模板1. 模板继承 模板继承是为了重用模板中的公共内容。一般Web开发中，继承主要使用在网站的顶部菜单、底部。这些内容可以定义在父模板中，子模板直接继承，而不需要重复书写。 标签定义的内容 {% block top %} {% endblock %} 相当于在父模板中挖个坑，当子模板继承父模板时，可以进行填充。 子模板使用 extends 指令声明这个模板继承自哪个模板 父模板中定义的块在子模板中被重新定义，在子模板中调用父模板的内容可以使用super() 1.1. 父模板 base.html {% block top %} 顶部菜单 {% endblock top %} {% block content %} {% endblock content %} {% block bottom %} 底部 {% endblock bottom %} 1.2. 子模板 extends指令声明这个模板继承自哪 {% extends 'base.html' %} {% block content %} 需要填充的内容 {% endblock content %} 模板继承使用时注意点： 不支持多继承 为了便于阅读，在子模板中使用extends时，尽量写在模板的第一行。 不能在一个模板文件中定义多个相同名字的block标签。 当在页面中使用多个block标签时，建议给结束标签起个名字，当多个block嵌套时，阅读性更好。 "},"mo-ban/mo-ban-dai-ma-fu-yong/bao-han.html":{"url":"mo-ban/mo-ban-dai-ma-fu-yong/bao-han.html","title":"2.6.3. 包含 ","keywords":"","body":"1. 包含2. 小结1. 包含 Jinja2模板中，除了宏和继承，还支持一种代码重用的功能，叫包含(Include)。它的功能是将另一个模板整个加载到当前模板中，并直接渲染。 include的使用 {% include 'hello.html' %} 包含在使用时，如果包含的模板文件不存在时，程序会抛出 TemplateNotFound 异常，可以加上 ignore missing 关键字。如果包含的模板文件不存在，会忽略这条include语句。 include 的使用加上关键字ignore missing {% include 'hello.html' ignore missing %} 2. 小结 宏(Macro)、继承(Block)、包含(include)均能实现代码的复用。 继承(Block)的本质是代码替换，一般用来实现多个页面中重复不变的区域。 宏(Macro)的功能类似函数，可以传入参数，需要定义、调用。 包含(include)是直接将目标模板文件整个渲染出来。 "},"mo-ban/te-you-bian-liang-he-han-shu.html":{"url":"mo-ban/te-you-bian-liang-he-han-shu.html","title":"2.7. 特有变量和函数 ","keywords":"","body":"1. 模板中特有的变量和函数1. 模板中特有的变量和函数 你可以在自己的模板中访问一些 Flask 默认内置的函数和对象 config 你可以从模板中直接访问Flask当前的config对象: {{config.SQLALCHEMY_DATABASE_URI}} sqlite:///database.db request 就是flask中代表当前请求的request对象： {{request.url}} http://127.0.0.1 session 为Flask的session对象 {{session.new}} True g变量 在视图函数中设置g变量的 name 属性的值，然后在模板中直接可以取出 {{ g.name }} url_for() url_for会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接: {{url_for('home')}} / 如果我们定义的路由URL是带有参数的,则可以把它们作为关键字参数传入url_for(),Flask会把他们填充进最终生成的URL中: {{ url_for('post', post_id=1)}} /post/1 get_flashed_messages() 这个函数会返回之前在flask中通过flask()传入的消息的列表，flash函数的作用很简单,可以把由Python字符串表示的消息加入一个消息队列中，再使用get_flashed_message()函数取出它们并消费掉： {%for message in get_flashed_messages()%} {{message}} {%endfor%} "},"mo-ban/flask-wtfbiao-dan.html":{"url":"mo-ban/flask-wtfbiao-dan.html","title":"2.8. Flask-WTF表单 ","keywords":"","body":"1. Web表单1.1. WTForms支持的HTML标准字段1.2. WTForms常用验证函数1.3. 代码验证1.3.1. 使用 html 自带的表单1.3.2. 使用 Flask-WTF 实现表单1. Web表单 Web 表单是 Web 应用程序的基本功能。 它是HTML页面中负责数据采集的部件。表单有三个部分组成：表单标签、表单域、表单按钮。表单允许用户输入数据，负责HTML页面数据采集，通过表单将用户输入的数据提交给服务器。 在Flask中，为了处理web表单，我们可以使用 Flask-WTF 扩展，它封装了 WTForms，并且它有验证表单数据的功能 1.1. WTForms支持的HTML标准字段 字段对象 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 HiddenField 隐藏文件字段 DateField 文本字段，值为 datetime.date 文本格式 DateTimeField 文本字段，值为 datetime.datetime 文本格式 IntegerField 文本字段，值为整数 DecimalField 文本字段，值为decimal.Decimal FloatField 文本字段，值为浮点数 BooleanField 复选框，值为True 和 False RadioField 一组单选框 SelectField 下拉列表 SelectMutipleField 下拉列表，可选择多个值 FileField 文件上传字段 SubmitField 表单提交按钮 FormField 把表单作为字段嵌入另一个表单 FieldList 一组指定类型的字段 1.2. WTForms常用验证函数 验证函数 说明 DataRequired 确保字段中有数据 EqualTo 比较两个字段的值，常用于比较两次密码输入 Length 验证输入的字符串长度 NumberRange 验证输入的值在数字范围内 URL 验证URL AnyOf 验证输入值在可选列表中 NoneOf 验证输入值不在可选列表中 使用 Flask-WTF 需要配置参数 SECRET_KEY。 CSRF_ENABLED是为了CSRF（跨站请求伪造）保护。 SECRET_KEY用来生成加密令牌，当CSRF激活的时候，该设置会根据设置的密匙生成加密令牌。 1.3. 代码验证 1.3.1. 使用 html 自带的表单 创建模板文件 login.html，在其中直接写form表单： &lt;form method=\"post\"&gt; &lt;label&gt;用户名：&lt;/label&gt;&lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\"&gt;&lt;br/&gt; &lt;label&gt;密码：&lt;/label&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;br/&gt; &lt;label&gt;确认密码：&lt;/label&gt;&lt;input type=\"password\" name=\"password2\" placeholder=\"请输入确认密码\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; {% for message in get_flashed_messages() %} {{ message }} {% endfor %} 视图函数中获取表单数据验证登录逻辑： @app.route('/demo1', methods=[\"get\", \"post\"]) def demo1(): if request.method == \"POST\": # 取到表单中提交上来的三个参数 username = request.form.get(\"username\") password = request.form.get(\"password\") password2 = request.form.get(\"password2\") if not all([username, password, password2]): # 向前端界面弹出一条提示(闪现消息) flash(\"参数不足\") elif password != password2: flash(\"两次密码不一致\") else: # 假装做注册操作 print(username, password, password2) return \"success\" return render_template('temp_register.html') 1.3.2. 使用 Flask-WTF 实现表单 配置参数，关闭 CSRF 校验 app.config['WTF_CSRF_ENABLED'] = False CSRF:跨站请求伪造，后续会讲到 模板页面： &lt;form method=\"post\"&gt; {{ form.username.label }} {{ form.username }}&lt;br/&gt; {{ form.password.label }} {{ form.password }}&lt;br/&gt; {{ form.password2.label }} {{ form.password2 }}&lt;br/&gt; {{ form.submit }} &lt;/form&gt; 视图函数： from flask import Flask,render_template, flash #导入wtf扩展的表单类 from flask_wtf import FlaskForm #导入自定义表单需要的字段 from wtforms import SubmitField,StringField,PasswordField #导入wtf扩展提供的表单验证器 from wtforms.validators import DataRequired,EqualTo app = Flask(__name__) app.config['SECRET_KEY']='SECRET_KEY' #自定义表单类，文本字段、密码字段、提交按钮 class RegisterForm(FlaskForm): username = StringField(\"用户名：\", validators=[DataRequired(\"请输入用户名\")], render_kw={\"placeholder\": \"请输入用户名\"}) password = PasswordField(\"密码：\", validators=[DataRequired(\"请输入密码\")]) password2 = PasswordField(\"确认密码：\", validators=[DataRequired(\"请输入确认密码\"), EqualTo(\"password\", \"两次密码不一致\")]) submit = SubmitField(\"注册\") #定义根路由视图函数，生成表单对象，获取表单数据，进行表单数据验证 @app.route('/demo2', methods=[\"get\", \"post\"]) def demo2(): register_form = RegisterForm() # 验证表单 if register_form.validate_on_submit(): # 如果代码能走到这个地方，那么就代码表单中所有的数据都能验证成功 username = request.form.get(\"username\") password = request.form.get(\"password\") password2 = request.form.get(\"password2\") # 假装做注册操作 print(username, password, password2) return \"success\" else: if request.method == \"POST\": flash(\"参数有误或者不完整\") return render_template('temp_register.html', form=register_form) if __name__ == '__main__': app.run(debug=True) 运行测试 "},"mo-ban/csrf.html":{"url":"mo-ban/csrf.html","title":"2.9. CSRF ","keywords":"","body":"1. CSRF1.1. CSRF攻击示意图1.2. 防止 CSRF 攻击1.2.1. 步骤1.2.2. 代码演示1.3. 在 Flask 项目中解决 CSRF 攻击1.3.1. 在 FlaskForm 中实现校验1.3.2. 单独使用1. CSRF CSRF全拼为Cross Site Request Forgery，译为跨站请求伪造。 CSRF指攻击者盗用了你的身份，以你的名义发送恶意请求。 包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账...... 造成的问题：个人隐私泄露以及财产安全。 1.1. CSRF攻击示意图 客户端访问服务器时没有同服务器做安全验证 1.2. 防止 CSRF 攻击 1.2.1. 步骤 在客户端向后端请求界面数据的时候，后端会往响应中的 cookie 中设置 csrf_token 的值 在 Form 表单中添加一个隐藏的的字段，值也是 csrf_token 在用户点击提交的时候，会带上这两个值向后台发起请求 后端接受到请求，以会以下几件事件： 从 cookie中取出 csrf_token 从 表单数据中取出来隐藏的 csrf_token 的值 进行对比 如果比较之后两值一样，那么代表是正常的请求，如果没取到或者比较不一样，代表不是正常的请求，不执行下一步操作 1.2.2. 代码演示 未进行 csrf 校验的 WebA 后端代码实现 from flask import Flask, render_template, make_response from flask import redirect from flask import request from flask import url_for app = Flask(__name__) @app.route('/', methods=[\"POST\", \"GET\"]) def index(): if request.method == \"POST\": # 取到表单中提交上来的参数 username = request.form.get(\"username\") password = request.form.get(\"password\") if not all([username, password]): print('参数错误') else: print(username, password) if username == 'laowang' and password == '1234': # 状态保持，设置用户名到cookie中表示登录成功 response = redirect(url_for('transfer')) response.set_cookie('username', username) return response else: print('密码错误') return render_template('temp_login.html') @app.route('/transfer', methods=[\"POST\", \"GET\"]) def transfer(): # 从cookie中取到用户名 username = request.cookies.get('username', None) # 如果没有取到，代表没有登录 if not username: return redirect(url_for('index')) if request.method == \"POST\": to_account = request.form.get(\"to_account\") money = request.form.get(\"money\") print('假装执行转操作，将当前登录用户的钱转账到指定账户') return '转账 %s 元到 %s 成功' % (money, to_account) # 渲染转换页面 response = make_response(render_template('temp_transfer.html')) return response if __name__ == '__main__': app.run(debug=True, port=9000) 前端登录页面代码 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是网站A，登录页面&lt;/h1&gt; &lt;form method=\"post\"&gt; &lt;label&gt;用户名：&lt;/label&gt;&lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\"&gt;&lt;br/&gt; &lt;label&gt;密码：&lt;/label&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 前端转账页面代码 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;转账&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是网站A，转账页面&lt;/h1&gt; &lt;form method=\"post\"&gt; &lt;label&gt;账户：&lt;/label&gt;&lt;input type=\"text\" name=\"to_account\" placeholder=\"请输入要转账的账户\"&gt;&lt;br/&gt; &lt;label&gt;金额：&lt;/label&gt;&lt;input type=\"number\" name=\"money\" placeholder=\"请输入转账金额\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"转账\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 运行测试，如果在未登录的情况下，不能直接进入转账页面，测试转账是成功的 攻击网站B的代码 后端代码实现 from flask import Flask from flask import render_template app = Flask(__name__) @app.route('/') def index(): return render_template('temp_index.html') if __name__ == '__main__': app.run(debug=True, port=8000) 前端代码实现 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是网站B&lt;/h1&gt; &lt;form method=\"post\" action=\"http://127.0.0.1:9000/transfer\"&gt; &lt;input type=\"hidden\" name=\"to_account\" value=\"999999\"&gt; &lt;input type=\"hidden\" name=\"money\" value=\"190000\" hidden&gt; &lt;input type=\"submit\" value=\"点击领取优惠券\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 运行测试，在用户登录网站A的情况下，点击网站B的按钮，可以实现伪造访问 在网站A中模拟实现 csrf_token 校验的流程 添加生成 csrf_token 的函数 # 生成 csrf_token 函数 def generate_csrf(): return bytes.decode(base64.b64encode(os.urandom(48))) 在渲染转账页面的，做以下几件事情： 生成 csrf_token 的值 在返回转账页面的响应里面设置 csrf_token 到 cookie 中 将 csrf_token 保存到表单的隐藏字段中 @app.route('/transfer', methods=[\"POST\", \"GET\"]) def transfer(): ... # 生成 csrf_token 的值 csrf_token = generate_csrf() # 渲染转换页面，传入 csrf_token 到模板中 response = make_response(render_template('temp_transfer.html', csrf_token=csrf_token)) # 设置csrf_token到cookie中，用于提交校验 response.set_cookie('csrf_token', csrf_token) return response 在转账模板表单中添加 csrf_token 隐藏字段 &lt;form method=\"post\"&gt; &lt;input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token }}\"&gt; &lt;label&gt;账户：&lt;/label&gt;&lt;input type=\"text\" name=\"to_account\" placeholder=\"请输入要转账的账户\"&gt;&lt;br/&gt; &lt;label&gt;金额：&lt;/label&gt;&lt;input type=\"number\" name=\"money\" placeholder=\"请输入转账金额\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"转账\"&gt; &lt;/form&gt; 运行测试，进入到转账页面之后，查看 cookie 和 html 源代码 在执行转账逻辑之前进行 csrf_token 的校验 if request.method == \"POST\": to_account = request.form.get(\"to_account\") money = request.form.get(\"money\") # 取出表单中的 csrf_token form_csrf_token = request.form.get(\"csrf_token\") # 取出 cookie 中的 csrf_token cookie_csrf_token = request.cookies.get(\"csrf_token\") # 进行对比 if cookie_csrf_token != form_csrf_token: return 'token校验失败，可能是非法操作' print('假装执行转操作，将当前登录用户的钱转账到指定账户') return '转账 %s 元到 %s 成功' % (money, to_account) 运行测试，用户直接在网站 A 操作没有问题，再去网站B进行操作，发现转账不成功，因为网站 B 获取不到表单中的 csrf_token 的隐藏字段，而且浏览器有 同 源策略，网站B是获取不到网站A的 cookie 的，所以就解决了 跨 站请求伪造的问题 1.3. 在 Flask 项目中解决 CSRF 攻击 在 Flask 中， Flask-wtf 扩展有一套完善的 csrf 防护体系，对于我们开发者来说，使用起来非常简单 1.3.1. 在 FlaskForm 中实现校验 设置应用程序的 secret_key 用于加密生成的 csrf_token 的值 app.secret_key = \"#此处可以写随机字符串#\" 在模板的表单中添加以下代码 &lt;form method=\"post\"&gt; {{ form.csrf_token() }} {{ form.username.label }} {{ form.username }}&lt;br/&gt; {{ form.password.label }} {{ form.password }}&lt;br/&gt; {{ form.password2.label }} {{ form.password2 }}&lt;br/&gt; {{ form.submit }} &lt;/form&gt; 渲染出来的前端页面为： 设置完毕，cookie 中的 csrf_token 不需要我们关心，会自动帮我们设置 1.3.2. 单独使用 设置应用程序的 secret_key 用于加密生成的 csrf_token 的值 app.secret_key = \"#此处可以写随机字符串#\" 导入 flask_wtf.csrf 中的 CSRFProtect 类，进行初始化，并在初始化的时候关联 app from flask.ext.wtf import CSRFProtect CSRFProtect(app) 如果模板中有表单，不需要做任何事。与之前一样: &lt;form method=\"post\"&gt; {{ form.csrf_token }} ... &lt;/form&gt; 但如果模板中没有表单，你仍需要 CSRF 令牌: &lt;form method=\"post\" action=\"/\"&gt; &lt;input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\" /&gt; &lt;/form&gt; 后续项目中会使用到此功能 "},"shu-ju-ku.html":{"url":"shu-ju-ku.html","title":"3. 数据库 ","keywords":"","body":"1. 数据库2. 学习目标1. 数据库 Flask-SQLAlchemy 安装及连接 使用数据库 综合案例演练 数据库迁移 2. 学习目标 能够理解 ORM 工作原理以及其优缺点 能够写出在 Flask 中连接 MySQL 的配置项格式（IP，端口，数据库） 能够使用 SQLAlchemy 定义出关系为一对多模型类 能够使用 SQLAlchemy 的相关函数创建表及删除表 能够写出的指定模型数据对数据库的增删改代码 能够写出模型数据按照条件查询的功能逻辑 能够写出模型数据按照指定数量分页的功能逻辑 能够写出模型数据按照指定条件排序的功能逻辑 能够按照课件步骤实现综合图书管理的相关案例 能够使用 Flask-Migrate 扩展对数据库进行迁移 "},"shu-ju-ku/orm.html":{"url":"shu-ju-ku/orm.html","title":"3.1. ORM ","keywords":"","body":"1. ORM1. ORM ORM 全拼Object-Relation Mapping. 中文意为 对象-关系映射. 主要实现模型对象到关系数据库数据的映射. 比如：把数据库表中每条记录映射为一个模型对象 ORM图解 优点 : 只需要面向对象编程, 不需要面向数据库编写代码. 对数据库的操作都转化成对类属性和方法的操作. 不用编写各种数据库的sql语句. 实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异. 不在关注用的是mysql、oracle...等. 通过简单的配置就可以轻松更换数据库, 而不需要修改代码. 缺点 : 相比较直接使用SQL语句操作数据库,有性能损失. 根据对象的操作转换成SQL语句,根据查询的结果转化成对象, 在映射过程中有性能损失. "},"shu-ju-ku/flask-sqlalchemyan-zhuang-ji-she-zhi.html":{"url":"shu-ju-ku/flask-sqlalchemyan-zhuang-ji-she-zhi.html","title":"3.2. Flask-SQLAlchemy安装及配置 ","keywords":"","body":"1. Flask-SQLAlchemy安装及设置1.1. 安装1.2. 数据库连接设置1.2.1. 连接其他数据库1.3. 常用的SQLAlchemy字段类型1.4. 常用的SQLAlchemy列选项1.5. 常用的SQLAlchemy关系选项1. Flask-SQLAlchemy安装及设置 SQLALchemy 实际上是对数据库的抽象，让开发者不用直接和 SQL 语句打交道，而是通过 Python 对象来操作数据库，在舍弃一些性能开销的同时，换来的是开发效率的较大提升 SQLAlchemy是一个关系型数据库框架，它提供了高层的 ORM 和底层的原生数据库的操作。flask-sqlalchemy 是一个简化了 SQLAlchemy 操作的flask扩展。 文档地址：http://docs.jinkan.org/docs/flask-sqlalchemy 1.1. 安装 安装 flask-sqlalchemy pip install flask-sqlalchemy 如果连接的是 mysql 数据库，需要安装 mysqldb pip install flask-mysqldb 1.2. 数据库连接设置 在 Flask-SQLAlchemy 中，数据库使用URL指定，而且程序使用的数据库必须保存到Flask配置对象的 SQLALCHEMY_DATABASE_URI 键中 app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/test' 其他设置： # 动态追踪修改设置，如未设置只会提示警告 app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True #查询时会显示原始SQL语句 app.config['SQLALCHEMY_ECHO'] = True 配置完成需要去 MySQL 中创建项目所使用的数据库 $ mysql -uroot -pmysql $ create database test charset utf8; 其他配置 名字 备注 SQLALCHEMY\\_DATABASE\\_URI 用于连接的数据库 URI 。例如:sqlite:////tmp/test.dbmysql://username:password@server/db SQLALCHEMY\\_BINDS 一个映射 binds 到连接 URI 的字典。更多 binds 的信息见 _用 Binds 操作多个数据库_。 SQLALCHEMY\\_ECHO 如果设置为Ture， SQLAlchemy 会记录所有 发给 stderr 的语句，这对调试有用。\\(打印sql语句\\) SQLALCHEMY\\_RECORD\\_QUERIES 可以用于显式地禁用或启用查询记录。查询记录 在调试或测试模式自动启用。更多信息见get\\_debug\\_queries\\(\\)。 SQLALCHEMY\\_NATIVE\\_UNICODE 可以用于显式禁用原生 unicode 支持。当使用 不合适的指定无编码的数据库默认值时，这对于 一些数据库适配器是必须的（比如 Ubuntu 上 某些版本的 PostgreSQL ）。 SQLALCHEMY\\_POOL\\_SIZE 数据库连接池的大小。默认是引擎默认值（通常 是 5 ） SQLALCHEMY\\_POOL\\_TIMEOUT 设定连接池的连接超时时间。默认是 10 。 SQLALCHEMY\\_POOL\\_RECYCLE 多少秒后自动回收连接。这对 MySQL 是必要的， 它默认移除闲置多于 8 小时的连接。注意如果 使用了 MySQL ， Flask-SQLALchemy 自动设定 这个值为 2 小时。 1.2.1. 连接其他数据库 完整连接 URI 列表请跳转到 SQLAlchemy 下面的文档 (Supported Databases) 。这里给出一些 常见的连接字符串。 Postgres: postgresql://scott:tiger@localhost/mydatabase MySQL: mysql://scott:tiger@localhost/mydatabase Oracle: - oracle://scott:tiger@127.0.0.1:1521/sidname SQLite （注意开头的四个斜线）: sqlite:////absolute/path/to/foo.db 1.3. 常用的SQLAlchemy字段类型 类型名 python中类型 说明 Integer int 普通整数，一般是32位 SmallInteger int 取值范围小的整数，一般是16位 BigInteger int或long 不限制精度的整数 Float float 浮点数 Numeric decimal.Decimal 普通整数，一般是32位 String str 变长字符串 Text str 变长字符串，对较长或不限长度的字符串做了优化 Unicode unicode 变长Unicode字符串 UnicodeText unicode 变长Unicode字符串，对较长或不限长度的字符串做了优化 Boolean bool 布尔值 Date datetime.date 时间 Time datetime.datetime 日期和时间 LargeBinary str 二进制文件 1.4. 常用的SQLAlchemy列选项 选项名 说明 primary\\_key 如果为True，代表表的主键 unique 如果为True，代表这列不允许出现重复的值 index 如果为True，为这列创建索引，提高查询效率 nullable 如果为True，允许有空值，如果为False，不允许有空值 default 为这列定义默认值 1.5. 常用的SQLAlchemy关系选项 选项名 说明 backref 在关系的另一模型中添加反向引用 primary join 明确指定两个模型之间使用的联结条件 uselist 如果为False，不使用列表，而使用标量值 order\\_by 指定关系中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondary join 在SQLAlchemy中无法自行决定时，指定多对多关系中的二级联结条件 "},"shu-ju-ku/shu-ju-ku-de-ji-ben-cao-zuo.html":{"url":"shu-ju-ku/shu-ju-ku-de-ji-ben-cao-zuo.html","title":"3.3. 数据库的基本操作 ","keywords":"","body":"1. 数据库基本操作1. 数据库基本操作 在Flask-SQLAlchemy中，插入、修改、删除操作，均由数据库会话管理。 会话用 db.session 表示。在准备把数据写入数据库前，要先将数据添加到会话中然后调用 commit() 方法提交会话。 在 Flask-SQLAlchemy 中，查询操作是通过 query 对象操作数据。 最基本的查询是返回表中所有数据，可以通过过滤器进行更精确的数据库查询。 在视图函数中定义模型类 from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) #设置连接数据库的URL app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/test' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True #查询时会显示原始SQL语句 app.config['SQLALCHEMY_ECHO'] = True db = SQLAlchemy(app) class Role(db.Model): # 定义表名 __tablename__ = 'roles' # 定义列对象 id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) us = db.relationship('User', backref='role') #repr()方法显示一个可读字符串 def __repr__(self): return 'Role:%s'% self.name class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True, index=True) email = db.Column(db.String(64),unique=True) password = db.Column(db.String(64)) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return 'User:%s'%self.name if __name__ == '__main__': app.run(debug=True) 模型之前的关联 一对多 class Role(db.Model): ... #关键代码 us = db.relationship('User', backref='role', lazy='dynamic') ... class User(db.Model): ... role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) 其中realtionship描述了Role和User的关系。在此文中，第一个参数为对应参照的类\"User\" 第二个参数backref为类User申明新属性的方法 第三个参数lazy决定了什么时候SQLALchemy从数据库中加载数据 如果设置为子查询方式(subquery)，则会在加载完Role对象后，就立即加载与其关联的对象，这样会让总查询数量减少，但如果返回的条目数量很多，就会比较慢 设置为 subquery 的话，role.users 返回所有数据列表 另外,也可以设置为动态方式(dynamic)，这样关联对象会在被使用的时候再进行加载，并且在返回前进行过滤，如果返回的对象数很多，或者未来会变得很多，那最好采用这种方式 设置为 dynamic 的话，role.users 返回查询对象，并没有做真正的查询，可以利用查询对象做其他逻辑，比如：先排序再返回结果 多对多 registrations = db.Table('registrations', db.Column('student_id', db.Integer, db.ForeignKey('students.id')), db.Column('course_id', db.Integer, db.ForeignKey('courses.id')) ) class Course(db.Model): ... class Student(db.Model): ... courses = db.relationship('Course',secondary=registrations, backref='students', lazy='dynamic') 常用的SQLAlchemy查询过滤器 过滤器 说明 filter\\(\\) 把过滤器添加到原查询上，返回一个新查询 filter\\_by\\(\\) 把等值过滤器添加到原查询上，返回一个新查询 limit 使用指定的值限定原查询返回的结果 offset\\(\\) 偏移原查询返回的结果，返回一个新查询 order\\_by\\(\\) 根据指定条件对原查询结果进行排序，返回一个新查询 group\\_by\\(\\) 根据指定条件对原查询结果进行分组，返回一个新查询 常用的SQLAlchemy查询执行器 方法 说明 all\\(\\) 以列表形式返回查询的所有结果 first\\(\\) 返回查询的第一个结果，如果未查到，返回None first\\_or\\_404\\(\\) 返回查询的第一个结果，如果未查到，返回404 get\\(\\) 返回指定主键对应的行，如不存在，返回None get\\_or\\_404\\(\\) 返回指定主键对应的行，如不存在，返回404 count\\(\\) 返回查询结果的数量 paginate\\(\\) 返回一个Paginate对象，它包含指定范围内的结果 创建表： db.create_all() 删除表 db.drop_all() 插入一条数据 ro1 = Role(name='admin') db.session.add(ro1) db.session.commit() #再次插入一条数据 ro2 = Role(name='user') db.session.add(ro2) db.session.commit() 一次插入多条数据 us1 = User(name='wang',email='wang@163.com',password='123456',role_id=ro1.id) us2 = User(name='zhang',email='zhang@189.com',password='201512',role_id=ro2.id) us3 = User(name='chen',email='chen@126.com',password='987654',role_id=ro2.id) us4 = User(name='zhou',email='zhou@163.com',password='456789',role_id=ro1.id) us5 = User(name='tang',email='tang@itheima.com',password='158104',role_id=ro2.id) us6 = User(name='wu',email='wu@gmail.com',password='5623514',role_id=ro2.id) us7 = User(name='qian',email='qian@gmail.com',password='1543567',role_id=ro1.id) us8 = User(name='liu',email='liu@itheima.com',password='867322',role_id=ro1.id) us9 = User(name='li',email='li@163.com',password='4526342',role_id=ro2.id) us10 = User(name='sun',email='sun@163.com',password='235523',role_id=ro2.id) db.session.add_all([us1,us2,us3,us4,us5,us6,us7,us8,us9,us10]) db.session.commit() \"\"\" 查询所有用户数据 查询有多少个用户 查询第1个用户 查询id为4的用户[3种方式] 查询名字结尾字符为g的所有数据[开始/包含] 查询名字不等于wang的所有数据[2种方式] 查询名字和邮箱都以 li 开头的所有数据[2种方式] 查询password是 `123456` 或者 `email` 以 `itheima.com` 结尾的所有数据 查询id为 [1, 3, 5, 7, 9] 的用户列表 查询name为liu的角色数据 查询所有用户数据，并以邮箱排序 每页3个，查询第2页的数据 \"\"\" 查询:filter_by精确查询 返回名字等于wang的所有人 User.query.filter_by(name='wang').all() first()返回查询到的第一个对象 User.query.first() all()返回查询到的所有对象 User.query.all() filter模糊查询，返回名字结尾字符为g的所有数据。 User.query.filter(User.name.endswith('g')).all() get():参数为主键，如果主键不存在没有返回内容 User.query.get() 逻辑非，返回名字不等于wang的所有数据 User.query.filter(User.name!='wang').all() not_ 相当于取反 from sqlalchemy import not_ User.query.filter(not_(User.name=='chen')).all() 逻辑与，需要导入and，返回and()条件满足的所有数据 from sqlalchemy import and_ User.query.filter(and_(User.name!='wang',User.email.endswith('163.com'))).all() 逻辑或，需要导入or_ from sqlalchemy import or_ User.query.filter(or_(User.name!='wang',User.email.endswith('163.com'))).all() 查询数据后删除 user = User.query.first() db.session.delete(user) db.session.commit() User.query.all() 更新数据 user = User.query.first() user.name = 'dong' db.session.commit() User.query.first() 关联查询示例： 角色和用户的关系是一对多的关系，一个角色可以有多个用户，一个用户只能属于一个角色。 查询角色的所有用户 #查询roles表id为1的角色 ro1 = Role.query.get(1) #查询该角色的所有用户 ro1.us.all() 查询用户所属角色 #查询users表id为3的用户 us1 = User.query.get(3) #查询用户属于什么角色 us1.role "},"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li.html":{"url":"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li.html","title":"3.4. 综合案例-图书管理 ","keywords":"","body":"1. 综合案例-图书管理1. 综合案例-图书管理 WTF表单 数据库操作 一对多关系演练 "},"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/ding-yi-mo-xing.html":{"url":"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/ding-yi-mo-xing.html","title":"3.4.1. 定义模型 ","keywords":"","body":"1. 定义模型1. 定义模型 模型表示程序使用的数据实体，在Flask- SQLAlchemy中，模型一般是Python类，继承自db.Model，db是SQLAlchemy类的实例，代表程序使用的数据库。 类中的属性对应数据库表中的列。id为主键，是由Flask-SQLAlchemy管理。db.Column类构造函数的第一个参数是数据库列和模型属性类型。 注：如果没有在创建数据库的时候指定编码的话，向数据库中插入中文后，会报错，那么需要修改数据库的编码集: alter database 数据库名 CHARACTER SET utf8 如下示例：定义了两个模型类，作者和书名。 #coding=utf-8 from flask import Flask,render_template,redirect,url_for from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) #设置连接数据 app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/test2' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True #实例化SQLAlchemy对象 db = SQLAlchemy(app) #定义模型类-作者 class Author(db.Model): __tablename__ = 'author' id = db.Column(db.Integer,primary_key=True) name = db.Column(db.String(32),unique=True au_book = db.relationship('Book',backref='author') def __repr__(self): return 'Author:%s' %self.name #定义模型类-书名 class Book(db.Model): __tablename__ = 'books' id = db.Column(db.Integer,primary_key=True) name = db.Column(db.String(32)) au_book = db.Column(db.Integer,db.ForeignKey('author.id')) def __str__(self): return 'Book:%s,%s'%(self.info,self.lead) "},"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/shu-ju-ku-biao-chuang-5efa26-ce-shi-shu-ju-tian-jia.html":{"url":"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/shu-ju-ku-biao-chuang-5efa26-ce-shi-shu-ju-tian-jia.html","title":"3.4.2. 数据库表创建 &测试数据添加 ","keywords":"","body":"创建表 if __name__ == '__main__': db.drop_all() db.create_all() app.run(debug=True) 查看创建结果 show tables; 查看author表结构 desc author; 查看books表结构 desc books; 添加测试数据 #生成数据 au1 = Author(name='老王') au2 = Author(name='老尹') au3 = Author(name='老刘') # 把数据提交给用户会话 db.session.add_all([au1, au2, au3]) # 提交会话 db.session.commit() bk1 = Book(name='老王回忆录', author_id=au1.id) bk2 = Book(name='我读书少，你别骗我', author_id=au1.id) bk3 = Book(name='如何才能让自己更骚', author_id=au2.id) bk4 = Book(name='怎样征服美丽少女', author_id=au3.id) bk5 = Book(name='如何征服英俊少男', author_id=au3.id) # 把数据提交给用户会话 db.session.add_all([bk1, bk2, bk3, bk4, bk5]) # 提交会话 db.session.commit() 生成数据后，查看数据： "},"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/shu-ju-xian-793a26-biao-dan-tian-jia.html":{"url":"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/shu-ju-xian-793a26-biao-dan-tian-jia.html","title":"3.4.3. 数据显示 &表单添加 ","keywords":"","body":"1. 数据显示&表单添加1.1. 数据显示1.2. 表单添加1. 数据显示&表单添加 1.1. 数据显示 定义路由函数，并将 Author 和 Book 的所有结果传到模板 @app.route('/',methods=['GET','POST']) def index(): author = Author.query.all() book = Book.query.all() return render_template('index.html',author=author,book=book) 模版关键代码 &lt;ul&gt; {% for x in author %} &lt;li&gt;{{ x }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;hr&gt; &lt;ul&gt; {% for x in book %} &lt;li&gt;{{ x }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; 效果图 1.2. 表单添加 定义表单类 from flask_wtf import FlaskForm from wtforms.validators import DataRequired from wtforms import StringField,SubmitField #创建表单类，用来添加信息 class Append(FlaskForm): au_info = StringField(validators=[DataRequired()]) bk_info = StringField(validators=[DataRequired()]) submit = SubmitField(u'添加') 传入至模版中 #创建表单对象 @app.route('/',methods=['GET','POST']) def index(): author = Author.query.all() book = Book.query.all() form = Append() return render_template('index.html',author=author,book=book,form=form) 模板中代码 &lt;form method=\"post\"&gt; {{ form.csrf_token }} &lt;p&gt;作者：{{ form.au_info }}&lt;/p&gt; &lt;p&gt;书名：{{ form.bk_info }}&lt;/p&gt; &lt;p&gt;{{ form.submit }}&lt;/p&gt; &lt;/form&gt; 效果图 "},"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/biao-dan-yan-zheng.html":{"url":"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/biao-dan-yan-zheng.html","title":"3.4.4. 表单验证 ","keywords":"","body":"1. 表单验证1. 表单验证 @app.route('/', methods=['get', 'post']) def index(): append_form = Append() if request.method == 'POST': if append_form.validate_on_submit(): author_name = append_form.au_info.data book_name = append_form.bk_info.data # 判断数据是否存在 author = Author.query.filter_by(name=author_name).first() if not author: try: # 先添加作者 author = Author(name=author_name) db.session.add(author) db.session.commit() # 再添加书籍 book = Book(name=book_name, author_id=author.id) db.session.add(book) db.session.commit() except Exception as e: db.session.rollback() print e flash(\"数据添加错误\") else: book_names = [book.name for book in author.books] if book_name in book_names: flash('该作者已存在相同的书名') else: try: book = Book(name=book_name, author_id=author.id) db.session.add(book) db.session.commit() except Exception as e: db.session.rollback() print e flash('数据添加错误') else: flash('数据输入有问题') authors = Author.query.all() books = Book.query.all() return render_template('test2.html', authors=authors, books=books, append_form=append_form) 重新编写html文件展示列表书籍 &lt;h2&gt;书籍列表&lt;/h2&gt; &lt;ul&gt; {% for author in authors %} &lt;li&gt; {{ author.name }} &lt;ul&gt; {% for book in author.books %} &lt;li&gt;{{ book.name }} {% else %} &lt;li&gt;无书籍&lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;/li&gt; {% endfor %} &lt;/ul&gt; 在form标签下添加 flash 消息的显示 {% for message in get_flashed_messages() %} {{ message }} {% endfor %} "},"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/shan-chu-shu-ju.html":{"url":"shu-ju-ku/zong-he-an-4f8b-tu-shu-guan-li/shan-chu-shu-ju.html","title":"3.4.5. 删除数据 ","keywords":"","body":"1. 删除数据1. 删除数据 定义删除author和book的路由 # 删除作者 @app.route('/delete_author/&lt;int:author_id&gt;') def delete_author(author_id): author = Author.query.get(author_id) if not author: flash('数据不存在') else: try: Book.query.filter_by(author_id=author_id).delete() db.session.delete(author) db.session.commit() except Exception as e: db.session.rollback() print e flash('操作数据库失败') return redirect(url_for('index')) # 删除书籍 @app.route('/delete_book/&lt;int:book_id&gt;') def delete_book(book_id): book = Book.query.get(book_id) if not book: flash('数据不存在') else: try: db.session.delete(book) db.session.commit() except Exception as e: db.session.rollback() print e flash('操作数据库失败') return redirect(url_for('index')) 在模版中添加删除的 a 标签链接 &lt;h2&gt;书籍列表&lt;/h2&gt; &lt;ul&gt; {% for author in authors %} &lt;li&gt; {{ author.name }} &lt;a href=\"/delete_author/{{ author.id }}\"&gt;删除&lt;/a&gt; &lt;ul&gt; {% for book in author.books %} &lt;li&gt;{{ book.name }} &lt;a href=\"/delete_book/{{ book.id }}\"&gt;删除&lt;/a&gt;&lt;/li&gt; {% else %} &lt;li&gt;无书籍&lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;/li&gt; {% endfor %} &lt;/ul&gt; "},"shu-ju-ku/duo-dui-duo-yan-lian.html":{"url":"shu-ju-ku/duo-dui-duo-yan-lian.html","title":"3.5. 多对多演练 ","keywords":"","body":"1. 多对多演练1.1. 场景示例1.1.1. 需求分析1.1.2. 思路分析1.1.3. 结果1.2. 代码演练1. 多对多演练 在项目开发过程中，会遇到很多数据之间多对多关系的情况，比如： 学生网上选课(学生和课程) 老师与其授课的班级(老师和班级) 用户与其收藏的新闻(用户和新闻) 等等... 所以在开发过程中需要使用 ORM 模型将表与表的多对多关联关系使用代码描述出来。多对多关系描述有一个唯一的点就是： 需 要添加一张单独的表去记录两张表之间的对应关系 1.1. 场景示例 1.1.1. 需求分析 学生可以网上选课，学生有多个，课程也有多个 学生有：张三、李四、王五 课程有：物理、化学、生物 选修关系有： 张三选修了化学和生物 李四选修了化学 王五选修了物理、化学和生物 需求： 查询某个学生选修了哪些课程 查询某个课程都有哪些学生选择 1.1.2. 思路分析 可以通过分析得出 用一张表来保存所有的学生数据 用一张表来保存所有的课程数据 具体表及测试数据可以如下： 学生表(Student) 主键\\(id\\) 学生名\\(name\\) 1 张三 2 李四 3 王五 选修课表(Course) 主键\\(id\\) 课程名\\(name\\) 1 物理 2 化学 3 生物 数据关联关系表(Student_Course) 主键\\(student.id\\) 主键\\(course.id\\) 1 2 1 3 2 2 3 1 3 2 3 3 1.1.3. 结果 查询某个学生选修了哪些课程，例如：查询王五选修了哪些课程 取出王五的 id 去 Student_Course 表中查询 student.id 值为 3 的所有数据 查询出来有3条数据，然后将这3条数据里面的 course.id 取值并查询 Course 表即可获得结果 查询某个课程都有哪些学生选择，例如：查询生物课程都有哪些学生选修 取出生物课程的 id 去 Student_Course 表中查询 course.id 值为 3 的所有数据 查询出来有2条数据，然后将这2条数据里面的 student.id 取值并查询 Student 表即可获得结果 1.2. 代码演练 定义模型及表 tb_student_course = db.Table('tb_student_course', db.Column('student_id', db.Integer, db.ForeignKey('students.id')), db.Column('course_id', db.Integer, db.ForeignKey('courses.id')) ) class Student(db.Model): __tablename__ = \"students\" id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) courses = db.relationship('Course', secondary=tb_student_course, backref='student', lazy='dynamic') class Course(db.Model): __tablename__ = \"courses\" id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) 添加测试数据 if __name__ == '__main__': db.drop_all() db.create_all() # 添加测试数据 stu1 = Student(name='张三') stu2 = Student(name='李四') stu3 = Student(name='王五') cou1 = Course(name='物理') cou2 = Course(name='化学') cou3 = Course(name='生物') stu1.courses = [cou2, cou3] stu2.courses = [cou2] stu3.courses = [cou1, cou2, cou3] db.session.add_all([stu1, stu2, stu2]) db.session.add_all([cou1, cou2, cou3]) db.session.commit() app.run(debug=True) "},"shu-ju-ku/shu-ju-ku-qian-yi.html":{"url":"shu-ju-ku/shu-ju-ku-qian-yi.html","title":"3.6. 数据库迁移 ","keywords":"","body":"1. 数据库迁移1. 数据库迁移 在开发过程中，需要修改数据库模型，而且还要在修改之后更新数据库。最直接的方式就是删除旧表，但这样会丢失数据。 更好的解决办法是使用数据库迁移框架，它可以追踪数据库模式的变化，然后把变动应用到数据库中。 在Flask中可以使用Flask-Migrate扩展，来实现数据迁移。并且集成到Flask-Script中，所有操作通过命令就能完成。 为了导出数据库迁移命令，Flask-Migrate提供了一个MigrateCommand类，可以附加到flask-script的manager对象上。 首先要在虚拟环境中安装Flask-Migrate。 pip install flask-migrate 代码文件内容： #coding=utf-8 from flask import Flask from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate,MigrateCommand from flask_script import Shell,Manager app = Flask(__name__) manager = Manager(app) app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@127.0.0.1:3306/Flask_test' app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True db = SQLAlchemy(app) #第一个参数是Flask的实例，第二个参数是Sqlalchemy数据库实例 migrate = Migrate(app,db) #manager是Flask-Script的实例，这条语句在flask-Script中添加一个db命令 manager.add_command('db',MigrateCommand) #定义模型Role class Role(db.Model): # 定义表名 __tablename__ = 'roles' # 定义列对象 id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) user = db.relationship('User', backref='role') #repr()方法显示一个可读字符串， def __repr__(self): return 'Role:'.format(self.name) #定义用户 class User(db.Model): __talbe__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) #设置外键 role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return 'User:'.format(self.username) if __name__ == '__main__': manager.run() 创建迁移仓库 #这个命令会创建migrations文件夹，所有迁移文件都放在里面。 python database.py db init 创建迁移脚本 自动创建迁移脚本有两个函数 upgrade()：函数把迁移中的改动应用到数据库中。 downgrade()：函数则将改动删除。 自动创建的迁移脚本会根据模型定义和数据库当前状态的差异，生成upgrade()和downgrade()函数的内容。 对比不一定完全正确，有可能会遗漏一些细节，需要进行检查 python database.py db migrate -m 'initial migration' 更新数据库 python database.py db upgrade 返回以前的版本 可以根据history命令找到版本号,然后传给downgrade命令: python app.py db history 输出格式：&lt;base&gt; -> 版本号 (head), initial migration 回滚到指定版本 python app.py db downgrade 版本号 实际操作顺序: 1.python 文件 db init 2.python 文件 db migrate -m\"版本名(注释)\" 3.python 文件 db upgrade 然后观察表结构 4.根据需求修改模型 5.python 文件 db migrate -m\"新版本名(注释)\" 6.python 文件 db upgrade 然后观察表结构 7.若返回版本,则利用 python 文件 db history查看版本号 8.python 文件 db downgrade(upgrade) 版本号 "},"shu-ju-ku/qi-ta.html":{"url":"shu-ju-ku/qi-ta.html","title":"3.7. 信号机制 ","keywords":"","body":"1. 信号机制1.1. Flask信号机制1.1.1. 信号应用场景1.2. Flask-SQLAlchemy 信号支持1. 信号机制 1.1. Flask信号机制 Flask信号(signals, or event hooking)允许特定的发送端通知订阅者发生了什么（既然知道发生了什么，那我们可以根据自己业务需求实现自己的逻辑）。 Flask提供了一些信号（核心信号）且其它的扩展提供更多的信号。 信号依赖于 Blinker 库。 pip install blinker flask内置信号列表：http://docs.jinkan.org/docs/flask/api.html\\#id17 template_rendered = _signals.signal('template-rendered') request_started = _signals.signal('request-started') request_finished = _signals.signal('request-finished') request_tearing_down = _signals.signal('request-tearing-down') got_request_exception = _signals.signal('got-request-exception') appcontext_tearing_down = _signals.signal('appcontext-tearing-down') appcontext_pushed = _signals.signal('appcontext-pushed') appcontext_popped = _signals.signal('appcontext-popped') message_flashed = _signals.signal('message-flashed') 1.1.1. 信号应用场景 Flask-User 这个扩展中定义了名为 user_logged_in 的信号，当用户成功登入之后，这个信号会被发送。我们可以订阅该信号去追踪登录次数和登录IP： from flask import request from flask_user.signals import user_logged_in @user_logged_in.connect_via(app) def track_logins(sender, user, **extra): user.login_count += 1 user.last_login_ip = request.remote_addr db.session.add(user) db.session.commit() 1.2. Flask-SQLAlchemy 信号支持 在 Flask-SQLAlchemy 模块中，0.10 版本开始支持信号，可以连接到信号来获取到底发生什么了的通知。存在于下面两个信号： models_committed 这个信号在修改的模型提交到数据库时发出。发送者是发送修改的应用，模型 和 操作描述符 以 (model, operation) 形式作为元组，这样的元组列表传递给接受者的 changes 参数。 该模型是发送到数据库的模型实例，当一个模型已经插入，操作是 'insert' ，而已删除是 'delete' ，如果更新了任何列，会是 'update' 。 before_models_committed 除了刚好在提交发送前发生，与 models_committed 完全相同。 from flask_sqlalchemy import models_committed # 给 models_committed 信号添加一个订阅者，即为当前 app @models_committed.connect_via(app) def models_committed(a, changes): print(a, changes) 对数据库进行增删改进行测试 "},"shu-ju-ku/chang-jian-guan-xi-mo-ban-dai-ma.html":{"url":"shu-ju-ku/chang-jian-guan-xi-mo-ban-dai-ma.html","title":"3.8. 常见关系模板代码 ","keywords":"","body":"1. 常见关系模板代码1.1. 一对多1.2. 多对多1.3. 自关联一对多1.4. 自关联多对多1. 常见关系模板代码 以下罗列了使用关系型数据库中常见关系定义模板代码 1.1. 一对多 示例场景： 用户与其发布的帖子(用户表与帖子表) 角色与所属于该角色的用户(角色表与多用户表) 示例代码 class Role(db.Model): \"\"\"角色表\"\"\" __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) users = db.relationship('User', backref='role', lazy='dynamic') class User(db.Model): \"\"\"用户表\"\"\" __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True, index=True) 1.2. 多对多 示例场景 讲师与其上课的班级(讲师表与班级表) 用户与其收藏的新闻(用户表与新闻表) 学生与其选修的课程(学生表与选修课程表) 示例代码 tb_student_course = db.Table('tb_student_course', db.Column('student_id', db.Integer, db.ForeignKey('students.id')), db.Column('course_id', db.Integer, db.ForeignKey('courses.id')) ) class Student(db.Model): __tablename__ = \"students\" id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) courses = db.relationship('Course', secondary=tb_student_course, backref=db.backref('students', lazy='dynamic'), lazy='dynamic') class Course(db.Model): __tablename__ = \"courses\" id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) 1.3. 自关联一对多 示例场景 评论与该评论的子评论(评论表) 参考网易新闻 示例代码 class Comment(db.Model): \"\"\"评论\"\"\" __tablename__ = \"comments\" id = db.Column(db.Integer, primary_key=True) # 评论内容 content = db.Column(db.Text, nullable=False) # 父评论id parent_id = db.Column(db.Integer, db.ForeignKey(\"comments.id\")) # 父评论(也是评论模型) parent = db.relationship(\"Comment\", remote_side=[id], backref=db.backref('childs', lazy='dynamic')) # 测试代码 if __name__ == '__main__': db.drop_all() db.create_all() com1 = Comment(content='我是主评论1') com2 = Comment(content='我是主评论2') com11 = Comment(content='我是回复主评论1的子评论1') com11.parent = com1 com12 = Comment(content='我是回复主评论1的子评论2') com12.parent = com1 db.session.add_all([com1, com2, com11, com12]) db.session.commit() app.run(debug=True) 1.4. 自关联多对多 示例场景 用户关注其他用户(用户表，中间表) 示例代码 tb_user_follows = db.Table( \"tb_user_follows\", db.Column('follower_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True), # 粉丝id db.Column('followed_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True) # 被关注人的id ) class User(db.Model): \"\"\"用户表\"\"\" __tablename__ = \"info_user\" id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(32), unique=True, nullable=False) # 用户所有的粉丝，添加了反向引用followed，代表用户都关注了哪些人 followers = db.relationship('User', secondary=tb_user_follows, primaryjoin=id == tb_user_follows.c.followed_id, secondaryjoin=id == tb_user_follows.c.follower_id, backref=db.backref('followed', lazy='dynamic'), lazy='dynamic') "},"lan-tu-dan-yuan-ce-shi.html":{"url":"lan-tu-dan-yuan-ce-shi.html","title":"4. 蓝图 &单元测试 ","keywords":"","body":"1. 蓝图&单元测试2. 学习目标1. 蓝图&单元测试 蓝图 单元测试 2. 学习目标 能够使用代码实现蓝图对项目进行模块化 能够说出断言的作用 能够说出实现单元测试步骤 能够说出单元测试所执行方法的定义规则 "},"lan-tu-dan-yuan-ce-shi/lan-tu.html":{"url":"lan-tu-dan-yuan-ce-shi/lan-tu.html","title":"4.1. 蓝图 ","keywords":"","body":"1. Blueprint1. Blueprint 模块化 随着flask程序越来越复杂,我们需要对程序进行模块化的处理,之前学习过python的模块化管理,于是针对一个简单的flask程序进行模块化处理 举例来说: 我们有一个博客程序,前台界面需要的路由为:首页,列表,详情等页面 源程序app.py文件: from flask import Flask app=Flask(__name__) @app.route('/') def index(): return 'index' @app.route('/list') def list(): return 'list' @app.route('/detail') def detail(): return 'detail' if __name__=='__main__': app.run() 如果博主需要编辑博客,要进入后台进行处理:后台主页,编辑,创建,发布博客 改进后程序: from flask import Flask app=Flask(__name__) @app.route('/') def index(): return 'index' @app.route('/list') def list(): return 'list' @app.route('/detail') def detail(): return 'detail' @app.route('/') def admin_home(): return 'admin_home' @app.route('/new') def new(): return 'new' @app.route('/edit') def edit(): return 'edit' @app.route('/publish') def publish(): return 'publish' if __name__=='__main__': app.run() 这样就使得我们在一个py文件中写入了很多路由,将来维护代码会非常麻烦,此时,同学们就考虑到了模块化的处理方式,将admin相关的路由写到一个admin.py文件中,那我们就顺着这个思路走下去 修改后的代码: app.py from flask import Flask app=Flask(__name__) @app.route('/') def index(): return 'index' @app.route('/list') def list(): return 'list' @app.route('/detail') def detail(): return 'detail' if __name__=='__main__': app.run() admin.py @app.route('/') def admin_home(): return 'admin_home' @app.route('/new') def new(): return 'new' @app.route('/edit') def edit(): return 'edit' @app.route('/publish') def publish(): return 'publish' 发现app.py文件中的app直接报错,代码无法继续写下去,所以在flask程序中,使用传统的模块化是行不通的,需要flask提供一个特有的模块化处理方式,flask内置了一个模块化处理的类,即Blueprint Blueprint概念 简单来说，Blueprint 是一个存储操作方法的容器，这些操作在这个Blueprint 被注册到一个应用之后就可以被调用，Flask 可以通过Blueprint来组织URL以及处理请求。 Flask使用Blueprint让应用实现模块化，在Flask中，Blueprint具有如下属性： 一个应用可以具有多个Blueprint 可以将一个Blueprint注册到任何一个未使用的URL下比如 \"/\"、\"/sample\"或者子域名 在一个应用中，一个模块可以注册多次 Blueprint可以单独具有自己的模板、静态文件或者其它的通用操作方法，它并不是必须要实现应用的视图和函数的 在一个应用初始化时，就应该要注册需要使用的Blueprint 但是一个Blueprint并不是一个完整的应用，它不能独立于应用运行，而必须要注册到某一个应用中。 初识蓝图 蓝图/Blueprint对象用起来和一个应用/Flask对象差不多，最大的区别在于一个 蓝图对象没有办法独立运行，必须将它注册到一个应用对象上才能生效 使用蓝图可以分为三个步骤 1,创建一个蓝图对象 admin=Blueprint('admin',__name__) 2,在这个蓝图对象上进行操作,注册路由,指定静态文件夹,注册模版过滤器 @admin.route('/') def admin_home(): return 'admin_home' 3,在应用对象上注册这个蓝图对象 app.register_blueprint(admin,url\\_prefix='/admin') 当这个应用启动后,通过/admin/可以访问到蓝图中定义的视图函数 运行机制 蓝图是保存了一组将来可以在应用对象上执行的操作，注册路由就是一种操作 当在应用对象上调用 route 装饰器注册路由时,这个操作将修改对象的url_map路由表 然而，蓝图对象根本没有路由表，当我们在蓝图对象上调用route装饰器注册路由时,它只是在内部的一个延迟操作记录列表defered_functions中添加了一个项 当执行应用对象的 register_blueprint() 方法时，应用对象将从蓝图对象的 defered_functions 列表中取出每一项，并以自身作为参数执行该匿名函数，即调用应用对象的 add_url_rule() 方法，这将真正的修改应用对象的路由表 蓝图的url前缀 当我们在应用对象上注册一个蓝图时，可以指定一个url_prefix关键字参数（这个参数默认是/） 在应用最终的路由表 url_map中，在蓝图上注册的路由URL自动被加上了这个前缀，这个可以保证在多个蓝图中使用相同的URL规则而不会最终引起冲突，只要在注册蓝图时将不同的蓝图挂接到不同的自路径即可 url_for url_for('admin.index') # /admin/ 注册静态路由 和应用对象不同，蓝图对象创建时不会默认注册静态目录的路由。需要我们在 创建时指定 static_folder 参数。 下面的示例将蓝图所在目录下的static_admin目录设置为静态目录 admin = Blueprint(\"admin\",__name__,static_folder='static_admin') app.register_blueprint(admin,url_prefix='/admin') 现在就可以使用/admin/static_admin/ 访问static_admin目录下的静态文件了 定制静态目录URL规则 ：可以在创建蓝图对象时使用 static_url_path 来改变静态目录的路由。下面的示例将为 static_admin 文件夹的路由设置为 /lib admin = Blueprint(\"admin\",__name__,static_folder='static_admin',static_url_path='/lib') app.register_blueprint(admin,url_prefix='/admin') 设置模版目录 蓝图对象默认的模板目录为系统的模版目录，可以在创建蓝图对象时使用 template_folder 关键字参数设置模板目录 admin = Blueprint('admin',__name__,template_folder='my_templates') 注:如果在 templates 中存在和 my_templates 同名文件,则系统会优先使用 templates 中的文件 参考链接：https://stackoverflow.com/questions/7974771/flask-blueprint-template- folder "},"lan-tu-dan-yuan-ce-shi/dan-yuan-ce-shi.html":{"url":"lan-tu-dan-yuan-ce-shi/dan-yuan-ce-shi.html","title":"4.2. 单元测试 ","keywords":"","body":"1. 单元测试1. 单元测试 为什么要测试？ Web程序开发过程一般包括以下几个阶段：[需求分析，设计阶段，实现阶段，测试阶段]。其中测试阶段通过人工或自动来运行测试某个系统的功能。目的是检验其是否满足需求，并得出特定的结果，以达到弄清楚预期结果和实际结果之间的差别的最终目的。 测试的分类： 测试从软件开发过程可以分为： 单元测试 对单独的代码块(例如函数)分别进行测试,以保证它们的正确性 集成测试 对大量的程序单元的协同工作情况做测试 系统测试 同时对整个系统的正确性进行检查,而不是针对独立的片段 在众多的测试中，与程序开发人员最密切的就是单元测试，因为单元测试是由开发人员进行的，而其他测试都由专业的测试人员来完成。所以我们主要学习单元测试。 什么是单元测试？ 程序开发过程中，写代码是为了实现需求。当我们的代码通过了编译，只是说明它的语法正确，功能能否实现则不能保证。 因此，当我们的某些功能代码完成后，为了检验其是否满足程序的需求。可以通过编写测试代码，模拟程序运行的过程，检验功能代码是否符合预期。 单元测试就是开发者编写一小段代码，检验目标代码的功能是否符合预期。通常情况下，单元测试主要面向一些功能单一的模块进行。 举个例子：一部手机有许多零部件组成，在正式组装一部手机前，手机内部的各个零部件，CPU、内存、电池、摄像头等，都要进行测试，这就是单元测试。 在Web开发过程中，单元测试实际上就是一些\"断言\"（assert）代码。 断言就是判断一个函数或对象的一个方法所产生的结果是否符合你期望的那个结果。 python中assert断言是声明布尔值为真的判定，如果表达式为假会发生异常。单元测试中，一般使用assert来断言结果。 断言方法的使用： 断言语句类似于： if not expression: raise AssertionError AssertionError 常 用的断言方法： assertEqual 如果两个值相等，则pass assertNotEqual 如果两个值不相等，则pass assertTrue 判断bool值为True，则pass assertFalse 判断bool值为False，则pass assertIsNone 不存在，则pass assertIsNotNone 存在，则pass 如何测试？ 简单的测试用例：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765， def fibo(x): if x == 0: resp = 0 elif x == 1: resp = 1 else: return fibo(x-1) + fibo(x-2) return resp assert fibo(5) == 5 单元测试的基本写法： 首 先，定义一个类，继承自unittest.TestCase import unittest class TestClass(unitest.TestCase): pass 其 次，在测试类中，定义两个测试方法 import unittest class TestClass(unittest.TestCase): #该方法会首先执行，方法名为固定写法 def setUp(self): pass #该方法会在测试代码执行完后执行，方法名为固定写法 def tearDown(self): pass 最 后，在测试类中，编写测试代码 import unittest class TestClass(unittest.TestCase): #该方法会首先执行，相当于做测试前的准备工作 def setUp(self): pass #该方法会在测试代码执行完后执行，相当于做测试后的扫尾工作 def tearDown(self): pass #测试代码 def test_app_exists(self): pass 登录测试 被测试的代码逻辑 @app.route('/login', methods=['POST']) def login(): username = request.form.get('username') password = request.form.get('password') # 判断参数是否为空 if not all([username, password]): result = { \"errcode\": -2, \"errmsg\": \"params error\" } return jsonify(result) # a = 1 / 0 # 如果账号密码正确 # 判断账号密码是否正确 if username == 'itheima' and password == 'python': result = { \"errcode\": 0, \"errmsg\": \"success\" } return jsonify(result) else: result = { \"errcode\": -1, \"errmsg\": \"wrong username or password\" } return jsonify(result) 单元测试代码 import json import unittest from demo1_login import app class LoginTest(unittest.TestCase): \"\"\"为登录逻辑编写测试案例\"\"\" def setUp(self): app.testing = True self.client = app.test_client() def test_empty_username_password(self): \"\"\"测试用户名与密码为空的情况[当参数不全的话，返回errcode=-2]\"\"\" response = app.test_client().post('/login', data={}) json_data = response.data json_dict = json.loads(json_data) self.assertIn('errcode', json_dict, '数据格式返回错误') self.assertEqual(json_dict['errcode'], -2, '状态码返回错误') # TODO 测试用户名为空的情况 # TODO 测试密码为空的情况 def test_error_username_password(self): \"\"\"测试用户名和密码错误的情况[当登录名和密码错误的时候，返回 errcode = -1]\"\"\" response = app.test_client().post('/login', data={\"username\": \"aaaaa\", \"password\": \"12343\"}) json_data = response.data json_dict = json.loads(json_data) self.assertIn('errcode', json_dict, '数据格式返回错误') self.assertEqual(json_dict['errcode'], -1, '状态码返回错误') # TODO 测试用户名错误的情况 # TODO 测试密码错误的情况 if __name__ == '__main__': unittest.main() 数据库测试： #coding=utf-8 import unittest from author_book import * #自定义测试类，setUp方法和tearDown方法会分别在测试前后执行。以test_开头的函数就是具体的测试代码。 class DatabaseTestCase(unittest.TestCase): def setUp(self): app.config['TESTING'] = True app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://root:mysql@localhost/test0' self.app = app db.create_all() def tearDown(self): db.session.remove() db.drop_all() #测试代码 def test_append_data(self): au = Author(name='itcast') bk = Book(info='python') db.session.add_all([au,bk]) db.session.commit() author = Author.query.filter_by(name='itcast').first() book = Book.query.filter_by(info='python').first() #断言数据存在 self.assertIsNotNone(author) self.assertIsNotNone(book) __ "}}